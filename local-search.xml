<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Redis学习笔记</title>
    <link href="/2020/08/31/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2020/08/31/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h3><p><a href="http://irfen.me/tag/redis">redis</a>是一个开源的高性能键值对<a href="http://irfen.me/tag/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a>。他通过提供多种键值数据类型来适应不同场景下的存储需求，并借助许多高层级的接口使其可以胜任如缓存、队列系统等不同的角色。</p><blockquote><p><code>nosql </code>非关系数据库   key=》value</p><p>redis  memcached   内存高速缓存数据库</p></blockquote><h3 id="二、可持久化（数据会同步到磁盘中）"><a href="#二、可持久化（数据会同步到磁盘中）" class="headerlink" title="二、可持久化（数据会同步到磁盘中）"></a>二、可持久化（数据会同步到磁盘中）</h3><ul><li><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4></li></ul><blockquote><p>RDB其实就是把数据以快照的形式保存在磁盘上。什么是快照呢，你可以理解成把当前时刻的数据拍成一张照片保存下来。</p><p>RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘。也是默认的持久化方式，这种方式是就是将内存中数据以快照的方式写入到二进制文件中,默认的文件名为<code>dump.rdb</code>。</p></blockquote><ul><li><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><blockquote><p>全量备份总是耗时的，有时候我们提供一种更加高效的方式AOF，工作机制很简单，redis会将每一个收到的写命令都通过<code>write</code>函数追加到文件中。通俗的理解就是日志记录。</p></blockquote></li></ul><h3 id="二、REDIS设置外网访问"><a href="#二、REDIS设置外网访问" class="headerlink" title="二、REDIS设置外网访问"></a>二、REDIS设置外网访问</h3><h4 id="1、两个相关配置"><a href="#1、两个相关配置" class="headerlink" title="1、两个相关配置"></a>1、两个相关配置</h4><blockquote><p>bind:指定可以来连接redis实例的ip<br>protected-mode:保护模式（除本机外，其他的都无法连接）<br><code>protected-mode</code>启用的条件，第一是没有使用bind，第二个是没有设置访问密码</p></blockquote><h4 id="2、设置外网访问"><a href="#2、设置外网访问" class="headerlink" title="2、设置外网访问"></a>2、设置外网访问</h4><ol><li>注视bind并且把<code>protected-mode</code>改为no</li><li>使用bind</li><li>设置密码</li></ol><h3 id="三、redis集群搭建"><a href="#三、redis集群搭建" class="headerlink" title="三、redis集群搭建"></a>三、redis集群搭建</h3><h4 id="1、集群类型"><a href="#1、集群类型" class="headerlink" title="1、集群类型"></a>1、集群类型</h4><blockquote><p>主从<br>哨兵<br>高可用</p></blockquote><h4 id="2、高可用集群部署"><a href="#2、高可用集群部署" class="headerlink" title="2、高可用集群部署"></a>2、<strong>高可用</strong>集群部署</h4><ul><li><h5 id="准备机器"><a href="#准备机器" class="headerlink" title="准备机器"></a>准备机器</h5></li></ul><blockquote><p>192.168.220.128<br>192.168.220.129<br>192.168.220.130</p></blockquote><ul><li><h5 id="部署规划"><a href="#部署规划" class="headerlink" title="部署规划"></a>部署规划</h5></li></ul><p>一台机器上可以运行一主一从redis实例，通过不同的配置文件实现。</p><blockquote><blockquote><p>192.168.220.128:<br>端口：7001（主）    7004（从）<br>192.168.220.129：<br>端口：7002（主）    7005（从）<br>192.168.220.130：<br>端口：7003（主）    7006（从）</p></blockquote></blockquote><ul><li><h5 id="每台机器准备安装redis"><a href="#每台机器准备安装redis" class="headerlink" title="每台机器准备安装redis"></a>每台机器准备安装redis</h5></li></ul><pre><code class="hljs shell">/opt/redisredis-5.0.8.tar.gz/opt/redistar -zxvf redis-5.0.8.tar.gz -C /home/rediscd /home/redis/redis-5.0.8make</code></pre><ul><li><h5 id="修改redis-conf"><a href="#修改redis-conf" class="headerlink" title="修改redis.conf"></a>修改redis.conf</h5></li></ul><p>1、将源配置复制到专门存放配置文件目录</p><p>​    <strong>192.168.220.128：</strong></p><pre><code class="hljs shell">mkdir /home/redis/redis_conf/7001mkdir /home/redis/redis_conf/7004cp /home/redis/redis-5.0.8/src/redis.conf /home/redis/redis_conf/7001cp /home/redis/redis-5.0.8/src/redis.conf /home/redis/redis_conf/7004</code></pre><p>2、修改</p><p>需要修改的配置</p><p><strong>192.168.220.128:7001</strong></p><p>创建集群工作目录，conf中需要配置</p><pre><code class="hljs shell">mkdir -p /home/redis/cluster/7001mkdir -p /home/redis/cluster/7004</code></pre><pre><code class="hljs shell">vim /home/redis/redis_conf/7001</code></pre><blockquote><p>daemonize yes 后台模式<br>port 7001 端口号<br>#bind 127.0.0.1 注释本地绑定<br>dir /home/redis/cluster/7001  集群工作目录（根据实际情况提前创建）<br>cluster-enable yes 开启集群模式<br>cluster-config-file nodes-7001.conf 集群配置文件信息<br>cluster-node-timeout 超时设置<br>appendonly  yes  持久化<br>protected-mode no 保护模式<br>requirepass redis 密码<br>masterauth redis 集群通信密码（需要和requirepass密码保持一致）</p></blockquote><pre><code class="hljs shell">vim /home/redis/redis_conf/7004</code></pre><blockquote><p>daemonize yes 后台模式<br>port 7004 端口号<br>#bind 127.0.0.1 注释本地绑定<br>dir /home/redis/cluster/7004  集群工作目录（根据实际情况提前创建）<br>cluster-enable yes 开启集群模式<br>cluster-config-file nodes-7004.conf 集群配置文件信息<br>cluster-node-timeout 超时设置<br>appendonly  yes  持久化<br>protected-mode no 保护模式<br>requirepass redis 密码<br>masterauth redis 集群通信密码（需要和requirepass密码保持一致）</p></blockquote><p>5）启动主从服务</p><pre><code class="hljs shell">cd /home/redis/redis-5.0.8/src./redis-server /home/redis/redis_conf/7001/redis.conf（启动指定配置好的7001的主配置文件）./redis-server /home/redis/redis_conf/7004/redis.conf（启动指定配置好的7004的从配置文件）</code></pre><p>检查服务</p><p> ps -ef | grep redis</p><pre><code class="hljs shell">root      15109      1  0 15:44 ?        00:00:23 ./redis-server *:7001 [cluster]root      15114      1  0 15:45 ?        00:00:24 ./redis-server *:7004 [cluster]root      15418   7101  0 17:38 pts/0    00:00:00 grep --color=auto redis</code></pre><p><strong>至此，192.168.220.128上面7001和1004主从redis已完成，其他两台配置一样，注意修改conf文件中port、dir 、cluster-config-file三项配置。</strong></p><h4 id="3、集群启动"><a href="#3、集群启动" class="headerlink" title="3、集群启动"></a>3、集群启动</h4><p>选择其中一台机器启动：</p><p>cd /home/redis/redis-5.0.8/src</p><pre><code class="hljs shell">./redis-cli -a redis --cluster create --cluster-replicas 1 192.168.220.128:7001 192.168.220.129:7002 192.168.220.130:7003 192.168.220.128:7004 192.168.220.129:7005 192.168.220.130:7006</code></pre><p>启动日志：</p><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt; Performing <span class="hljs-built_in">hash</span> slots allocation on 6 nodes...</span>Master[0] -&gt; Slots 0 - 5460Master[1] -&gt; Slots 5461 - 10922Master[2] -&gt; Slots 10923 - 16383Adding replica 192.168.220.129:7005 to 192.168.220.128:7001Adding replica 192.168.220.130:7006 to 192.168.220.129:7002Adding replica 192.168.220.128:7004 to 192.168.220.130:7003M: 5751ccf39c172abe7ede54ceb152cabfcc054340 192.168.220.128:7001   slots:[0-5460] (5461 slots) masterM: 9024ab249744a894a76bb993a5749c8985ce834d 192.168.220.129:7002   slots:[5461-10922] (5462 slots) masterM: f02a28331b391b8483dc3e8b083e38a1bee82b13 192.168.220.130:7003   slots:[10923-16383] (5461 slots) masterS: 31e33cc31cc35697fd2abf88c185658939a35271 192.168.220.128:7004   replicates f02a28331b391b8483dc3e8b083e38a1bee82b13S: c81c6332f0ad579329ddda6528786abfe22c513d 192.168.220.129:7005   replicates 5751ccf39c172abe7ede54ceb152cabfcc054340S: 981b250d5695c8dc54342e8dc19200a39b7c4313 192.168.220.130:7006   replicates 9024ab249744a894a76bb993a5749c8985ce834dCan I set the above configuration? (type &#x27;yes&#x27; to accept): yes<span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt; Nodes configuration updated</span><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt; Assign a different config epoch to each node</span><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt; Sending CLUSTER MEET messages to join the cluster</span>Waiting for the cluster to join.............<span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt; Performing Cluster Check (using node 192.168.220.128:7001)</span>M: 5751ccf39c172abe7ede54ceb152cabfcc054340 192.168.220.128:7001   slots:[0-5460] (5461 slots) master   1 additional replica(s)M: f02a28331b391b8483dc3e8b083e38a1bee82b13 192.168.220.130:7003   slots:[10923-16383] (5461 slots) master   1 additional replica(s)S: 31e33cc31cc35697fd2abf88c185658939a35271 192.168.220.128:7004   slots: (0 slots) slave   replicates f02a28331b391b8483dc3e8b083e38a1bee82b13S: c81c6332f0ad579329ddda6528786abfe22c513d 192.168.220.129:7005   slots: (0 slots) slave   replicates 5751ccf39c172abe7ede54ceb152cabfcc054340S: 981b250d5695c8dc54342e8dc19200a39b7c4313 192.168.220.130:7006   slots: (0 slots) slave   replicates 9024ab249744a894a76bb993a5749c8985ce834dM: 9024ab249744a894a76bb993a5749c8985ce834d 192.168.220.129:7002   slots:[5461-10922] (5462 slots) master   1 additional replica(s)[OK] All nodes agree about slots configuration.<span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt; Check <span class="hljs-keyword">for</span> open slots...</span><span class="hljs-meta">&gt;</span><span class="bash">&gt;&gt; Check slots coverage...</span>[OK] All 16384 slots covered.</code></pre><p>连接集群命令：<code>./redis-cli -a redis -c -h  ip  -p  port</code></p><pre><code class="hljs shell">cd /home/redis/redis-5.0.8/src./redis-cli -a redis -c -h 192.168.220.129 -p 7002</code></pre><pre><code class="hljs shell">192.168.220.129:7002&gt; keys *(empty list or set)192.168.220.129:7002&gt; set k1 v1<span class="hljs-meta">-&gt;</span><span class="bash"> Redirected to slot [12706] located at 192.168.220.130:7003</span>OK192.168.220.130:7003&gt; set k2 v2<span class="hljs-meta">-&gt;</span><span class="bash"> Redirected to slot [449] located at 192.168.220.128:7001</span>OK192.168.220.128:7001&gt; keys *1) &quot;k2&quot;192.168.220.128:7001&gt; set k3 v3OK192.168.220.128:7001&gt; set k4 v4<span class="hljs-meta">-&gt;</span><span class="bash"> Redirected to slot [8455] located at 192.168.220.129:7002</span>OK192.168.220.129:7002&gt; quit</code></pre><p><strong>参考文档：<a href="https://www.jianshu.com/p/be14306f5fd8">https://www.jianshu.com/p/be14306f5fd8</a></strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Harbor搭建与使用</title>
    <link href="/2020/08/30/Harbor%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/08/30/Harbor%E6%90%AD%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="Harbor介绍"><a href="#Harbor介绍" class="headerlink" title="Harbor介绍"></a>Harbor介绍</h3><p>Habor是由VMWare公司开源的容器镜像仓库。事实上，Habor是在Docker Registry上进行了相应的企业级扩展，从而获得了更加广泛的应用，这些新的企业级特性包括：管理用户界面，基于角色的访问控制 ，AD/LDAP集成以及审计日志等，足以满足基本企业需求。</p><h3 id="Harbor安装部署"><a href="#Harbor安装部署" class="headerlink" title="Harbor安装部署"></a>Harbor安装部署</h3><h4 id="一、前期准备"><a href="#一、前期准备" class="headerlink" title="一、前期准备"></a>一、前期准备</h4><h5 id="1、安装docker"><a href="#1、安装docker" class="headerlink" title="1、安装docker"></a>1、安装docker</h5><pre><code class="hljs shell">wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repoyum -y install docker-ce-18.06.1.ce-3.el7systemctl enable docker &amp;&amp; systemctl start dockerdocker --version</code></pre><blockquote><p>Docker version 18.06.1-ce, build e68fc7a</p></blockquote><h5 id="2、下载harbor安装包"><a href="#2、下载harbor安装包" class="headerlink" title="2、下载harbor安装包"></a>2、下载harbor安装包</h5><p><code>Github地址</code>：<a href="https://github.com/goharbor/harbor/releases/tag/v1.8.5">https://github.com/goharbor/harbor/releases/tag/v1.8.5</a></p><pre><code class="hljs shell">tar -zxvf harbor-offline-installer-v1.8.5.tgz -C /homepwd/home/harborlscommon  docker-compose.yml  harbor.v1.8.5.tar.gz  harbor.yml  install.sh  LICENSE  prepare</code></pre><h5 id="3、修改harbor-yml"><a href="#3、修改harbor-yml" class="headerlink" title="3、修改harbor.yml"></a>3、修改harbor.yml</h5><p><code> vim harbor.yml</code></p><blockquote><p>hostname: 192.168.220.131（修改为ip或者域名）<br>port: 8090 （默认80，自行修改）<br>harbor_admin_password: Harbor12345（登录harbor密码，自行修改）<br>data_volume: /home/data/harbor_data（数据存放目录，自行修改）</p></blockquote><p><code>vim /etc/docker/daemon.json</code></p><pre><code class="hljs shell">&#123; &quot;insecure-registries&quot; : [&quot;192.168.220.131:8090&quot;]&#125;</code></pre><p>重启docker</p><pre><code class="hljs bash">systemctl daemon-reloadsystemctl restart docker</code></pre><h5 id="4、访问harbor"><a href="#4、访问harbor" class="headerlink" title="4、访问harbor"></a>4、访问harbor</h5><pre><code class="hljs shell">http://192.168.220.131:8090/</code></pre><p>新建项目：<code>nathaniel-e</code></p><p>推送镜像：</p><blockquote><p>docker login <a href="http://192.168.220.131:8090/">http://192.168.220.131:8090</a><br>admin<br>Harbor12345<br>docker tag SOURCE_IMAGE[:TAG] 192.168.220.131:8090/nathaniel-e/IMAGE[:TAG]<br>docker push 192.168.220.131:8090/nathaniel-e/IMAGE[:TAG]</p></blockquote><p><strong>参考文档：</strong></p><p><strong><a href="https://www.jianshu.com/p/4f9474081c8a">https://www.jianshu.com/p/4f9474081c8a</a></strong></p><p><strong><a href="https://www.meiwen.com.cn/subject/qwedoftx.html">https://www.meiwen.com.cn/subject/qwedoftx.html</a></strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>Harbor</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper入门看这篇就够了</title>
    <link href="/2020/08/30/Zookeeper%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
    <url>/2020/08/30/Zookeeper%E5%85%A5%E9%97%A8%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<h2 id="zookeeper特点"><a href="#zookeeper特点" class="headerlink" title="zookeeper特点"></a>zookeeper特点</h2><blockquote><ul><li>zookeeper：一个领导者（leader），多个跟随着（follower）组成的集群。</li><li>集群中只要有半数以上的节点存活，zookeeper集群就能正常服务。</li><li>全局数据一致：每个server保存相同的数据副本，client无论连接到哪一个server，数据都是一致的。</li><li>更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行。</li><li>数据更新原子性，一次数据更新要么成功，要么失败。</li><li>实时性，在一定时间范围内，client连接到最新数据。</li></ul></blockquote><h2 id="zookeeper数据结构"><a href="#zookeeper数据结构" class="headerlink" title="zookeeper数据结构"></a>zookeeper数据结构</h2><blockquote><p>zookeeper数据模型和unix文件系统类似，每一个节点叫做一个ZNode。每一个ZNode默认能够存储1MB的数据，每个ZNode都可以通过其路径唯一标识。</p></blockquote><h2 id="zookeeper应用场景"><a href="#zookeeper应用场景" class="headerlink" title="zookeeper应用场景"></a>zookeeper应用场景</h2><ul><li><p>统一命名服务</p><p>分布式环境下，经常需要对应用服务统一命名，便于识别。</p><pre><code>`IP不容易记住，域名可以`</code></pre></li><li><p>统一配置管理</p><p>分布式环境下，配置文件同步。</p><ol><li>集群下，所有节点的配置信息是一致的，如<code>Kafka</code>集群</li><li>对配置文件修改后，快速同步到各个节点上</li></ol><p>配置管理可交由zookeeper实现。</p><ol><li>可将配置信息写入zookeeper上的一个<code>ZNode</code></li><li>各个客户端服务器监听这个<code>ZNode</code></li><li>一旦ZNode中的数据被修改，zookeeper将通知各个<code>客户端服务器</code></li></ol></li><li><p>统一集群管理</p><p>分布式环境下，实时掌握每个节点的状态。</p><ol><li>可根据节点实时状态做一些调整    </li></ol><p>zookeeper可以实现实时监控节点状态变化。</p><ol><li>可将节点信息写入zookeeper上的<code>ZNode</code></li><li>监听这个<code>NZode</code>可获取它的实时状态变化</li></ol></li><li><p>服务器动态上下线</p><p>客户端能实时洞察到服务器上下线的变化。</p></li><li><p>软负载均衡</p><p>在zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求。</p></li></ul><h2 id="zookeeper节点类型"><a href="#zookeeper节点类型" class="headerlink" title="zookeeper节点类型"></a>zookeeper节点类型</h2><blockquote><p><code>持久</code>：客户端和服务器端断开连接后，创建的节点不删除。</p><p><code>短暂</code>：客户端和服务器端断开连接后，创建的节点自己删除。</p></blockquote><h2 id="zookeeper集群部署"><a href="#zookeeper集群部署" class="headerlink" title="zookeeper集群部署"></a>zookeeper集群部署</h2><p><code>官网地址</code>：<a href="https://zookeeper.apache.org/">https://zookeeper.apache.org</a></p><ol><li><p>准备3台机器</p><blockquote><blockquote><p>vm001       192.168.220.128<br>vm002       192.168.220.129<br>vm003       192.168.220.130</p></blockquote></blockquote></li><li><p>每台机器安装jdk</p><pre><code class="hljs she">1）下载jdk包2）tar -zxvf jdk-8u191-linux-x64.tar.gz -C &#x2F;usr&#x2F;local3）添加环境变量：vim &#x2F;etc&#x2F;profileexport JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk1.8.0_191export PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin更新配置文件：source &#x2F;etc&#x2F;profile4）验证：   echo $JAVA_HOME    java -version</code></pre></li><li><p>下载apache-zookeeper-3.5.8-bin.tar.gz包</p><p><code>解压tar -zxvf apache-zookeeper-3.5.8-bin.tar.gz -C /home/zookeeper</code></p></li><li><p>每台机器修改配置</p><ul><li><p>首先将zoo_sample.cfg配置文件修名为<code>zoo.cfg</code></p></li><li><p>vim zoo.cfg</p><pre><code class="hljs shell">a、修改数据存储目录：dataDir=/opt/zkDatab、在配置末尾添加serverserver.1=192.168.220.128:2881:3881server.2=192.168.220.129:2881:3881server.3=192.168.220.130:2881:3881</code></pre></li><li><p>在数据目录/opt/zkData中创建myid文件</p></li></ul></li><li><p>启动服务</p><p><code>启动Server服务</code></p><pre><code class="hljs shell"><span class="hljs-meta">]#</span><span class="bash">./zkServer.sh start</span></code></pre><pre><code class="hljs shell">ZooKeeper JMX enabled by defaultUsing config: /home/zookeeper/apache-zookeeper-3.5.8-bin/bin/../conf/zoo.cfgStarting zookeeper ... STARTED</code></pre><p><code>查看状态</code></p><pre><code class="hljs shell"><span class="hljs-meta">]#</span><span class="bash">./zkServer.sh status</span></code></pre><pre><code class="hljs shell">ZooKeeper JMX enabled by defaultUsing config: /home/zookeeper/apache-zookeeper-3.5.8-bin/bin/../conf/zoo.cfgClient port found: 2181. Client address: localhost.Mode: leader</code></pre></li><li><p>注意事项</p><p>关闭防火墙，放通端口。</p></li></ol><pre><code class="hljs shell">firewall-cmd --zone=public --add-port=2181/tcp --permanentfirewall-cmd --zone=public --add-port=2881/tcp --permanentfirewall-cmd --zone=public --add-port=3881/tcp --permanentfirewall-cmd --reloadfirewall-cmd --zone=public --query-port=2181/tcpfirewall-cmd --zone=public --list-ports</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx笔记基于docker</title>
    <link href="/2020/08/30/Nginx%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8EDocker/"/>
    <url>/2020/08/30/Nginx%E5%AD%A6%E4%B9%A0%E5%9F%BA%E4%BA%8EDocker/</url>
    
    <content type="html"><![CDATA[<h3 id="Nginx介绍"><a href="#Nginx介绍" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h3><h4 id="1-1引言"><a href="#1-1引言" class="headerlink" title="1.1引言"></a>1.1引言</h4><p><strong>为什么要学习Nginx</strong><br>问题1：客户端到底要将请求发送给哪台服务器<br>问题2：如果所有客户端的请求都发送给了服务器<br>问题3：客户端发送的请求可能是申请动态资源的，也有申请静态资源的</p><p><code>服务器搭建集群后</code></p><p><img src="https://img-blog.csdnimg.cn/20200804144611463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="Image text"></p><p><code>在搭建集群后，使用Nginx做反向代理</code></p><p><img src="https://img-blog.csdnimg.cn/20200804144623426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="{}}"></p><h4 id="1-2Nginx介绍"><a href="#1-2Nginx介绍" class="headerlink" title="1.2Nginx介绍"></a>1.2Nginx介绍</h4><p>Nginx是由俄罗斯人研发的，应对Rambler的网站并发，并且2004年发布的第一个版本。</p><p><code>Nginx的特点</code></p><ul><li>稳定性极强，7*24小时不间断运行(就是一直运行)</li><li>Nginx提供了非常丰富的配置实例</li><li>占用内存小，并发能力强(随便配置一下就是5w+,而tomcat的默认线程池是150)</li></ul><h3 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h3><h4 id="2-1安装Nginx"><a href="#2-1安装Nginx" class="headerlink" title="2.1安装Nginx"></a>2.1安装Nginx</h4><p>在/opt目录下创建docker_nginx目录</p><pre><code class="hljs shell">cd /optmkdir docker_nginx</code></pre><p>创建docker-compose.yml文件并编写下面的内容,保存退出</p><pre><code class="hljs shell">vim docker-compose.yml</code></pre><pre><code class="hljs json">version: &#x27;3.1&#x27;services:   nginx:    restart: always    image: daocloud.io/library/nginx:latest    container_name: nginx    ports:       - 80:80</code></pre><p>执行<code>docker-compose up -d</code></p><p>访问80端口，看到下图说明安装成功（ncthz.top是我阿里云服务器的域名，大家输入自己服务器的Ip就可以访问80端口了）</p><p><img src="https://img-blog.csdnimg.cn/20200804144702568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="Image text"></p><h4 id="2-2Nginx的配置文件"><a href="#2-2Nginx的配置文件" class="headerlink" title="2.2Nginx的配置文件"></a>2.2Nginx的配置文件</h4><p>查看当前nginx的配置需要进入docker容器中</p><pre><code class="hljs shell">docker exec -it 容器id bash</code></pre><p>进入容器后</p><pre><code class="hljs shell">cd /etc/nginx/cat nginx.conf</code></pre><p><code>nginx.conf</code>文件内容如下</p><pre><code class="hljs json">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;# 以上同城为全局块# worker_processes的数值越大，Nginx的并发能力就越强# error_log代表Nginx错误日志存放的位置# pid是Nginx运行的一个标识events &#123;    worker_connections  1024;&#125;# events块# worker_connections的数值越大，Nginx的并发能力就越强http &#123;    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    include /etc/nginx/conf.d/*.conf;&#125;# http块# include代表引入一个外部文件# include       /etc/nginx/mime.types;mime.types中存放着大量媒体类型#include /etc/nginx/conf.d/*.conf;引入了conf.d下以.conf为结尾的配置文件</code></pre><p>conf.d目录下只有一个<code>default.conf</code>文件，内容如下</p><pre><code class="hljs json">server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;    #charset koi8-r;    #access_log  /var/log/nginx/host.access.log  main;    location / &#123;        root   /usr/share/nginx/html;        index  index.html index.htm;    &#125;# location块# root:将接受到的请求根据/usr/share/nginx/html去查找静态资源# index:默认去上述的路径中找到index.html或index.htm    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   /usr/share/nginx/html;    &#125;    # proxy the PHP scripts to Apache listening on 127.0.0.1:80    #    #location ~ \.php$ &#123;    #    proxy_pass   http://127.0.0.1;    #&#125;    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000    #    #location ~ \.php$ &#123;    #    root           html;    #    fastcgi_pass   127.0.0.1:9000;    #    fastcgi_index  index.php;    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;    #    include        fastcgi_params;    #&#125;    # deny access to .htaccess files, if Apache&#x27;s document root    # concurs with nginx&#x27;s one    #    #location ~ /\.ht &#123;    #    deny  all;    #&#125;&#125;# server块# listen代表Nginx监听的端口号# server_name代表Nginx接受请求的IP</code></pre><h4 id="2-3修改docker-compose文件"><a href="#2-3修改docker-compose文件" class="headerlink" title="2.3修改docker-compose文件"></a>2.3修改<code>docker-compose</code>文件</h4><p>退出容器并关闭容器</p><pre><code class="hljs shell">exitdocker-compose down</code></pre><p>修改docker-compose.yml文件如下</p><pre><code class="hljs json">version: &#x27;3.1&#x27;services:   nginx:    restart: always    image: daocloud.io/library/nginx:latest    container_name: nginx    ports:       - 80:80    volumes:      - /opt/docker_nginx/conf.d/:/etc/nginx/conf.d</code></pre><p>重新构建容器</p><pre><code class="hljs shell">docker-compose bulid</code></pre><p>重新启动容器</p><pre><code class="hljs shell">docker-compose up -d</code></pre><p>这时我们再次访问80端口是访问不到的，因为我们映射了数据卷之后还没有编写server块中的内容</p><p>我们在<code>/opt/docker_nginx/conf.d</code>下新建<code>default.conf</code>，并插入如下内容</p><pre><code class="hljs json">server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;    location / &#123;        root   /usr/share/nginx/html;        index  index.html index.htm;    &#125;&#125;</code></pre><p>重启nginx</p><pre><code class="hljs shell">docker-compose restart</code></pre><p>这时我们再访问80端口，可以看到是访问成功的</p><h3 id="Nginx的反向代理"><a href="#Nginx的反向代理" class="headerlink" title="Nginx的反向代理"></a>Nginx的反向代理</h3><h4 id="3-1正向代理和反向代理介绍"><a href="#3-1正向代理和反向代理介绍" class="headerlink" title="3.1正向代理和反向代理介绍"></a>3.1正向代理和反向代理介绍</h4><p><code>正向代理</code>：<br>1.正向代理服务是由客户端设立的<br>2.客户端了解代理服务器和目标服务器都是谁<br>3.帮助咱们实现突破访问权限，提高访问的速度，对目标服务器隐藏客户端的ip地址</p><p><img src="https://img-blog.csdnimg.cn/20200804144856773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="Image text"></p><p><code>反向代理</code>：<br>1.反向代理服务器是配置在服务端的<br>2.客户端不知道访问的到底是哪一台服务器<br>3.达到负载均衡，并且可以隐藏服务器真正的ip地址</p><p><img src="https://img-blog.csdnimg.cn/20200804144918883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="Image text"></p><h4 id="3-2基于Nginx实现反向代理"><a href="#3-2基于Nginx实现反向代理" class="headerlink" title="3.2基于Nginx实现反向代理"></a>3.2基于Nginx实现反向代理</h4><blockquote><blockquote><p>准备一个目标服务器<br>启动tomcat服务器<br>编写nginx的配置文件(/opt/docker_nginx/conf.d/default.conf)，通过Nginx访问到tomcat服务器</p></blockquote></blockquote><p>准备tomcat服务器</p><pre><code class="hljs shell">docker run -d -p 8080:8080 --name tomcat  daocloud.io/library/tomcat:8.5.15-jre8</code></pre><p>或者已经下载了tomcat镜像</p><pre><code class="hljs shell">docker run -d -p 8080:8080 --name tomcat 镜像的标识</code></pre><p>添加数据卷</p><pre><code class="hljs shell">docker run -it -v /宿主机绝对目录:/容器内目录 镜像名</code></pre><p><code>default.conf</code>文件内容如下</p><pre><code class="hljs json">server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;    location / &#123;        proxy_pass http://ncthz.top:8080/;    &#125;&#125;</code></pre><p>重启nginx</p><pre><code class="hljs shell">docker-compose restart</code></pre><p>这时我们访问80端口可以看到8080端口tomcat的默认首页</p><h4 id="3-3关于Nginx的location路径映射"><a href="#3-3关于Nginx的location路径映射" class="headerlink" title="3.3关于Nginx的location路径映射"></a>3.3关于Nginx的location路径映射</h4><blockquote><p>优先级关系：<br>(location = ) &gt; (location /xxx/yyy/zzz) &gt; (location ^<del>) &gt; (location ~,</del>*) &gt; (location /起始路径) &gt; (location /)</p></blockquote><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1. = 匹配</span>location / &#123;<span class="hljs-meta">#</span><span class="bash">精准匹配，主机名后面不能带能和字符串</span><span class="hljs-meta">#</span><span class="bash">例如www.baidu.com不能是www.baidu.com/id=xxx</span>&#125;</code></pre><hr><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">2. 通用匹配</span>location /xxx &#123;<span class="hljs-meta">#</span><span class="bash">匹配所有以/xxx开头的路径</span><span class="hljs-meta">#</span><span class="bash">例如127.0.0.1:8080/xxxxxx可以为空，为空则和=匹配一样</span>&#125;</code></pre><hr><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">3. 正则匹配</span>location ~ /xxx &#123;<span class="hljs-meta">#</span><span class="bash">匹配所有以/xxx开头的路径</span>&#125;</code></pre><hr><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">4. 匹配开头路径</span>location ^~ /xxx/xx &#123;<span class="hljs-meta">#</span><span class="bash">匹配所有以/xxx/xx开头的路径</span>&#125;</code></pre><hr><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">5. 匹配结尾路径</span>location ~* \.(gif/jpg/png)$ &#123;<span class="hljs-meta">#</span><span class="bash">匹配以.gif、.jpg或者.png结尾的路径</span>&#125;</code></pre><p>修改<code>/opt/docker_nginx/conf.d/default.conf</code>如下</p><pre><code class="hljs json">server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;location /index &#123;        proxy_pass http://ncthz.top:8081/;#tomcat首页    &#125;location ^~ /CR/ &#123;        proxy_pass http://ncthz.top:8080/CR/;#毕设前台首页    &#125;    location / &#123;        proxy_pass http://ncthz.top:8080/CRAdmin/;#毕设后台首页    &#125;&#125;</code></pre><p>重启nginx</p><pre><code class="hljs shell">docker-compose restart</code></pre><p>访问ncthz.top/index可以进入tomcat首页<br>访问ncthz.top/CR/XXX可以进入毕设前台首页<br>访问ncthz.top或者ncthz.top:80可以进入毕设后台首页</p><h3 id="Nginx负载均衡"><a href="#Nginx负载均衡" class="headerlink" title="Nginx负载均衡"></a>Nginx负载均衡</h3><ul><li>Nginx为我们默认提供了三种负载均衡的策略：<br>轮询：<br>  将客户端发起的请求，平均分配给每一台服务器</li><li>权重：<br>  会将客户端的请求，根据服务器的权重值不同，分配不同的数量</li><li>ip_hash:<br>  基于发起请求的客户端的ip地址不同，他始终会将请求发送到指定的服务器上<br>  就是说如果这个客户端的请求的ip地址不变，那么处理请求的服务器将一直是同一个</li></ul><h4 id="4-1轮询"><a href="#4-1轮询" class="headerlink" title="4.1轮询"></a>4.1轮询</h4><p>想实现Nginx轮询负载均衡机制只需要修改配置文件如下</p><pre><code class="hljs json">upstream my_server&#123;    server ncthz.top:8080;    server ncthz.top:8081;&#125;server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;location / &#123;        proxy_pass http://my_server/;#tomcat首页    &#125;&#125;</code></pre><pre><code class="hljs json">upstream 名字&#123;    server ip:端口;    server 域名:端口;&#125;server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;location / &#123;        proxy_pass http://upstream的名字/;    &#125;&#125;</code></pre><p>重启nginx</p><pre><code class="hljs shell">docker-compose restart</code></pre><p>多次刷新ncthz.top页面，根据版本号我们可以发现我们进入的是不同的tomcat</p><p><img src="https://img-blog.csdnimg.cn/20200804145017833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="Image text"></p><p><img src="https://img-blog.csdnimg.cn/2020080414503175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="Image text"></p><h4 id="4-2权重"><a href="#4-2权重" class="headerlink" title="4.2权重"></a>4.2权重</h4><p>实现权重的方式：在配置文件中upstream块中加上<code>weight</code></p><pre><code class="hljs json">upstream my_server&#123;    server ncthz.top:8080 weight=10;    server ncthz.top:8081 weight=2;&#125;server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;location / &#123;        proxy_pass http://my_server/;#tomcat首页    &#125;&#125;</code></pre><h4 id="4-3ip-hash"><a href="#4-3ip-hash" class="headerlink" title="4.3ip_hash"></a>4.3ip_hash</h4><p>实现ip_hash方式：在配置文件upstream块中加上<code>ip_hash</code>;</p><pre><code class="hljs json">upstream my_server&#123;ip_hash;    server ncthz.top:8080 weight=10;    server ncthz.top:8081 weight=2;&#125;server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;location / &#123;        proxy_pass http://my_server/;#tomcat首页    &#125;&#125;</code></pre><h3 id="Nginx动静分离"><a href="#Nginx动静分离" class="headerlink" title="Nginx动静分离"></a>Nginx动静分离</h3><blockquote><blockquote><p>Nginx的并发能力公式：<br> <code>worker_processes * worker_connections / 4|2 = Nginx最终的并发能力</code><br>动态资源需要/4，静态资源需要/2<br>Nginx通过动静分离来提升Nginx的并发能力，更快的给用户响应</p></blockquote></blockquote><h4 id="5-1动态资源代理"><a href="#5-1动态资源代理" class="headerlink" title="5.1动态资源代理"></a>5.1动态资源代理</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">配置如下</span>location / &#123;  proxy_pass 路径;&#125;</code></pre><h4 id="5-2静态资源代理"><a href="#5-2静态资源代理" class="headerlink" title="5.2静态资源代理"></a>5.2静态资源代理</h4><p>停掉nginx</p><pre><code class="hljs shell">docker-compose down</code></pre><p>修改docker-compose.yml添加静态资源数据卷<br>不同版本的静态资源位置可能不同，可以在2.2中查看默认的位置（location块中root后的路径）</p><p>启动nginx</p><pre><code class="hljs shell">docker-compose up -d</code></pre><pre><code class="hljs json">version: &#x27;3.1&#x27;services:   nginx:    restart: always    image: daocloud.io/library/nginx:latest    container_name: nginx    ports:       - 80:80    volumes:      - /opt/docker_nginx/conf.d/:/etc/nginx/conf.d      - /opt/docker_nginx/html/:/usr/share/nginx/html</code></pre><pre><code class="hljs json">在/opt/docker_nginx/html下新建一个index.html在index.html里面随便写点东西展示修改nginx的配置文件location / &#123;    root /usr/share/nginx/html;    index index.html;&#125;</code></pre><p>配置如下</p><pre><code class="hljs json">location / &#123;    root 静态资源路径;    index 默认访问路径下的什么资源;    autoindex on;#代表展示静态资源的全部内容，以列表的形式展开&#125;</code></pre><p>重启nginx</p><pre><code class="hljs shell">docker-compose restart</code></pre><p>访问ncthz.top如下</p><p><img src="https://img-blog.csdnimg.cn/20200804145109582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="Image text"></p><h3 id="Nginx集群"><a href="#Nginx集群" class="headerlink" title="Nginx集群"></a>Nginx集群</h3><h4 id="6-1引言"><a href="#6-1引言" class="headerlink" title="6.1引言"></a>6.1引言</h4><blockquote><p>单点故障，避免nginx的宕机，导致整个程序的崩溃<br>准备多台Nginx<br>准备keepalived，监听nginx的健康情况<br>准备haproxy，提供一个虚拟的路径，统一的去接收用户的请求</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200804145126982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="Image text"></p><h4 id="6-2搭建"><a href="#6-2搭建" class="headerlink" title="6.2搭建"></a>6.2搭建</h4><blockquote><p>先准备好以下文件放入/opt/docker_nginx_cluster目录中<br>然后启动容器    注意确保80、8081和8082端口未被占用(或者修改docker-compose.yml中的端口)<br>docker-compose up -d</p><p>然后我们访问8081端口可以看到master，访问8082端口可以看到slave<br>因为我们设置了81端口的master优先级未200比82端口的slave优先级100高，所以我们访问80端口看到的是master<br>现在我们模仿8081端口的nginx宕机了<br>docker stop 8081端口nginx容器的ID<br>这时我们再去访问80端口看到的就是slave了</p></blockquote><p><code>Dockerfile</code></p><pre><code class="hljs json">FROM nginx:1.13.5-alpineRUN apk update &amp;&amp; apk upgradeRUN apk add --no-cache bash curl ipvsadm iproute2 openrc keepalivedCOPY entrypoint.sh /entrypoint.shRUN chmod +x /entrypoint.shCMD [&quot;/entrypoint.sh&quot;]</code></pre><p><code>entrypoint.sh</code></p><pre><code class="hljs json">#!/bin/sh#/usr/sbin/keepalvined -n -l -D -f /etc/keepalived/keepalived.conf --dont-fork --log-console &amp;/usr/sbin/keepalvined -D -f /etc/keepalived/keepalived.confnginx -g &quot;daemon off;&quot;</code></pre><p><code>docker-compose.yml</code></p><pre><code class="hljs json">version: &quot;3.1&quot;services:  nginx_master:    build:      context: ./      dockerfile: ./Dockerfile    ports:      -8081:80    volumes:      - ./index-master.html:/usr/share/nnginx/html/index.html      - ./favicon.ico:/usr/share/nnginx/html/favicon.ico      - ./keepalived-master.conf:/etv/keepalived/keepalived.conf    networks:      static-network:        ipv4_address:172.20.128.2    cap_add:      - NET_ADMIN  nginx_slave:    build:      context: ./      dockerfile: ./Dockerfile    ports:      -8082:80    volumes:      - ./index-slave.html:/usr/share/nnginx/html/index.html      - ./favicon.ico:/usr/share/nnginx/html/favicon.ico      - ./keepalived-slave.conf:/etv/keepalived/keepalived.conf    networks:      static-network:        ipv4_address:172.20.128.3    cap_add:      - NET_ADMIN  proxy:    image:  haproxy:1.7-apline    ports:      - 80:6301    volumes:      - ./happroxy.cfg:/usr/local/etc/haproxy/haproxy.cfg    networks:      - static-networknetworks:  static-network:    ipam:      congig:        - subnet: 172.20.0.0/16</code></pre><p><code>keepalived-master.conf</code></p><pre><code class="hljs json">vrrp_script chk_nginx &#123;    script &quot;pidof nginx&quot;    interval 2&#125;vrrp_instance VI_1 &#123;    state MASTER    interface etch0#容器内部的网卡名称    virtual_router_id 33    priority 200#优先级    advert_int 1        autheentication &#123;    auth_type PASS    auth_pass letmein&#125;virtual_ipaddress &#123;        172.20.128.50#虚拟路径    &#125;track_script &#123;        chk_nginx    &#125;&#125;</code></pre><p><code>keepalived-slave.conf</code></p><pre><code class="hljs json">vrrp_script chk_nginx &#123;    script &quot;pidof nginx&quot;    interval 2&#125;vrrp_instance VI_1 &#123;    state BACKUP    interface etch0#容器内部的网卡名称    virtual_router_id 33    priority 100#优先级    advert_int 1        autheentication &#123;    auth_type PASS    auth_pass letmein&#125;virtual_ipaddress &#123;        172.20.128.50#虚拟路径    &#125;track_script &#123;        chk_nginx    &#125;&#125;</code></pre><p><code>haproxy.cfg</code></p><pre><code class="hljs json">globallog 127.0.0.1 local0maxconn 4096daemonnbproc 4defaultslog 127.0.0.1 local3mode httpoption dontlognulloption redispatchretries 2maxconn 2000balance roundrobintimeout connect 5000mstimeout client 5000mstimeout server 5000msfrontend mainbind *:6301default_backend webserverbackend webserveerserver nginx_master 127.20.127.50:80 check inter 2000 rise 2 fall 5</code></pre><p><code>index-master.html</code></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>master！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre><p><code>index-slave.html</code></p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>slave！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Git+hexo搭建个人博客</title>
    <link href="/2020/08/30/%E4%BD%BF%E7%94%A8Git-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/08/30/%E4%BD%BF%E7%94%A8Git-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>用流行的 Hexo 博客系统，利用 Github Pages，搭建个人博客，使用 Markdown 语法进行写作，发布博客后，借用 Markdown 美化工具，生成公众号、知乎、头条等平台的文章格式，发布到相应平台。</p><h3 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h3><ul><li><p><strong>Hexo</strong><br>Hexo 是流行的博客框架，能集成多种插件和主题，可以生成各种类型的博客，具有很好的生态圈，并且在不断升级优化中，不用担心年久失修。</p></li><li><p><strong>Github pages</strong><br>Github 是一个基于 Git 版本管理工具的代码托管平台，是全球最大的开源代码平台，pages 是 Github 给用户提供的一种建立静态网页的服务，创建好之后，只要将做好的静态页面上传到 Github 上，就能被全球的能联网的人访问了。</p></li><li><p><strong>Markdown</strong><br>Markdown 是一种简单标记方法，使用简单规则，就可以做出美观的页面，比使用 Html 标记等语言制作页面方便的多，熟悉了标记规则之后，创作过程可以完全忘记标记的存在，并且大多数编辑器，包括在线编辑器都支持 。Markdown 语法，使用 Markdown 语法写的文章，可以很方便的在不同平台上共享，而不用担心文章格式受到改变。</p></li><li><p><strong>Markdown 美化工具</strong><br>Markdown 之所以简单，是因为它只提炼了文章格式相关的标记，比如标题，列表，加粗，斜体，代码块等，而将样式部分完全交给了解释程序，也就是说相同的格式可以被美化为不同风格的文章样式，所以就有了 Markdown 美化工具，只要将 markdown 文本粘贴到编辑器，就能查看美化后的效果，并且还可以切换不同风格，直到自己满意。<br>简单说 Markdown 美化工具就是将 markdown 文本转换为 Html 文本。</p></li><li><p><strong>操作系统</strong><br>Hexo 是基于 Nodejs 的，所以支持 Windows、Linux 和 MacOS，这里只以 Windows 为例讲解。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>Hexo 是基于 Nodejs 的，也就是用 Nodejs 写的一个应用，另外 Hexo 相关组件和包都是放在 Github 上的，所以还需要一个 git 工具，以便和 Github 交互</p><h3 id="安装-nvm"><a href="#安装-nvm" class="headerlink" title="安装 nvm"></a>安装 nvm</h3><p>Nodejs 版本很多，软件包也很多，常常令初学者头疼，现在有了专门管理 Nodejs 环境的工具 nvm，通过 nvm 可以简单的安装不同版本的 Nodejs，并且可以在不同版本之间切换，从而解决 Nodejs 的版本混乱问题</p><ol><li>下载安装包<br>这里这里 <a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a> 选择最新版本的安装包，下载 zip 文件，例如目前最新版是 1.1.7，下载地址是<br><a href="https://github.com/coreybutler/nvm-windows/releases/download/1.1.7/nvm-noinstall.zip">https://github.com/coreybutler/nvm-windows/releases/download/1.1.7/nvm-noinstall.zip</a></li><li>将下载的 zip 包解压到你的程序安装目录，例如 D:\Software\nvm</li><li>在刚才解压的文件夹，双击运行 install.cmd 文件，中间可能会提示需要使用管理员权限，选择是即可</li><li>由于 nodejs 软件目录国内访问较慢，有必要设置下软件源，即让 nvm 从指定的地方下载 nodejs，方法是在环境变量中加一个 <code>NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node</code><br>如果不清楚如何设置，可以参考这里<a href="https://jingyan.baidu.com/article/8ebacdf02d3c2949f65cd5d0.html">https://jingyan.baidu.com/article/8ebacdf02d3c2949f65cd5d0.html</a></li></ol><h3 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h3><p>有了 nvm 就能轻松地安装 nodejs 了</p><p>打开一个命令行窗口，输入 <code>nvm install 12.18.2</code></p><p><code>12.18.2</code> 为 nodejs 目前最新的稳定版本号，可以在这里参看最新的版本号 <a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p><p>成功安装后，在命令行中输入 node –version 就可以看到版本号信息，如 v12.18.2，安装 nodejs 的同时，会安装好 npm，即 nodejs 的软件包管理器，用来管理 nodejs 的各种扩展软件包，如果了解 python 的话，和 pip 很相似</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>Hexo 实际上是一个 nodejs 的软件包，可以通过 npm 来安装，在安装之前，最好换以下 npm 的软件源，以便国内访问更快些，在命令行中输入命令：</p><pre><code class="hljs shell">nvm node_mirror https://npm.taobao.org/mirrors/node/nvm npm_mirror https://npm.taobao.org/mirrors/npm/</code></pre><p>注意用的是 nvm 而不是 npm，这两个命令，会在 nvm 安装文件夹下创建一个 settings.txt 文件，写入镜像网址，当然不用上述命令，自己创建 settings.txt,输入镜像网址也是一样的，settings.txt 内容为：</p><pre><code class="hljs shell">node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/</code></pre><ul><li>注意这里用的是 <strong>npm</strong> 而不是 nvm</li><li>参数 g 表示全局安装，即在任何目录下都可以使用</li></ul><p>安装完成后，输入 <code>hexo --version</code> 可以看到包括 hexo 版本在内一些环境信息</p><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p>Git 可以管理本地的软件版本，也能和 Github 打交道，而且 GIT 工具集成了 Linux 的命令环境，可以在 Git 命令行下使用 Linux 命令，而且语法高亮，比较方便</p><p>下载 Git windows 安装程序 <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p><p>完成后，双击运行安装程序</p><p>一路选择默认设计就行，因为配置项很多，如果不想一步步选，可以勾选安装窗口的 <code>only show new options</code> 勾选框</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wMS5wbmc?x-oss-process=image/format,png" alt="git 安装选项"></p><p>安装完成后，如果不使用 git 来管理代码（对于写作来说就是文章），可以不用关注 git 的相关用法，只要知道可以通过鼠标右键菜单，启动一个 git 命令窗口就行了</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wMi5wbmc?x-oss-process=image/format,png" alt="Git Bash Here "></p><blockquote><p>安装时不同的选择导致的快捷菜单可能不同</p></blockquote><h3 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h3><p>环境准备好后，就可以构建博客系统了.</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>创建一个博客目录，例如：<code>D:\myblog</code>，到改目录下，鼠标右键，选择 <code>Git Bash Here</code> 菜单，会进入一个命令行窗口，和 Windows 的命令行窗口类似</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wMy5wbmc?x-oss-process=image/format,png" alt="git 命令窗口"></p><p>在这里输入命令 <code>hexo init</code>，回车，会下载博客程序，当提示 <code>INFO Start blogging with Hexo!</code> 时候，说明创建完成</p><p>接着输入 <code>hexo server</code> 或者 <code>hexo s</code> 启动 Hexo 博客程序了</p><p>在浏览器中输入 localhost:4000，就可以查看博客了</p><blockquote><p>有时候 localhost:4000 没有很长时间没有反应，可能是 4000 端口被其他程序占用了，这时输入 Ctrl + C 结束 Hexo 程序，换个端口启动就好了，例如 <code>hexo s -p 5000</code> , 参数 <code>-p</code> 表示指定端口，5000 为指定的端口</p></blockquote><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>默认启动的博客是英文版的，另外默认的主题是 landscape，如果不喜欢可以更好</p><p>在博客根目录下，<code>_config.yml</code> 为配置文件，配置项很多，只需要设置很少部分就可以</p><p>站点设置 site，设置博客站点的基本信息</p><ul><li>title 站点名称</li><li>subtitle 副标题</li><li>description 站点描述</li><li>keywords 站点关键字，方便搜索引擎归类</li><li>author 作者名称</li><li>language 语言，简体中文为 <code>zh-CN</code></li><li>timezone 时区</li></ul><p>域名设置 URL，即为博客设置个网址</p><ul><li>url 网址，例如 <a href="http://blog.lixiaofei.cn/">http://blog.lixiaofei.cn</a></li><li>root 表示博客的根目录，如果设置为 /blog 那么网址会是 url 加上这个根路径</li><li>permalink 为固定网址，表示每篇文章的网址组成部分</li></ul><blockquote><p>如果自己的域名，需要购买，例如在万网上购买，之后需要实名认证，然后将域名解析到博客服务器地址上，服务器地址将在 Github pages 部分详细说明</p></blockquote><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>Hexo 自带了 landscape 主题，可以跟换其他的</p><p>在 <a href="https://hexo.io/themes/index.html">https://hexo.io/themes/index.html</a> 这里预览可用主题</p><p>选择喜欢的主题，找到 github 地址，一般都在预览页中有提供，复制主题项目的 github 地址：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wNC5wbmc?x-oss-process=image/format,png" alt="img"></p><p>进入博客根目录，右键选择 <code>Git Bash Here</code>，打开 git 命令行，输入 <code>git clone [主题github 项目地址地址] theme/[主题英文名称]</code> 回车执行</p><p>执行完成后，博客目录下 theme 里 会多一个 主题英文名称的文件夹，这就是刚才下载的主题</p><p>打开 Hexo 配置文件 <code>_config.yml</code> 找到 <code>theme</code> 配置项，修改为 <code>主题英文名称</code></p><p>正常情况下刷浏览器的页面就可以看到新主题效果了，如果不行，执行下 <code>hexo server</code> 就可以了</p><p>每个主题有自己不同的配置项，配置文件是对应主题文件夹中的 <code>_config.yml</code>，相关配置可以参考该主题的帮助文档</p><p>这里建议选择使用者多，支持丰富的主题，相对而言文档全，bug 少</p><h4 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h4><p>Github 不仅是很多开源软件的仓库，还可以成为我们博客的服务器，最重要的是免费，国内有类似的产品 Gitee（码云）提供类似功能</p><h5 id="注册和创建项目"><a href="#注册和创建项目" class="headerlink" title="注册和创建项目"></a>注册和创建项目</h5><p>访问 <a href="https://github.com/">https://github.com</a>，选择 sign up 填写必要信息完成注册，注册完成后，点击 sign in 登录</p><p>登录后，点击页面右上角附近的 <code>加号</code>，在弹出菜单中选择 <code>New repository</code></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wNS5wbmc?x-oss-process=image/format,png" alt="img"></p><p>在打开的页面中，填写项目名称，可以随要填写，因为作为博客使用，选择公开仓库，并且勾选为项目创建 <code>Readme</code></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wNi5wbmc?x-oss-process=image/format,png" alt="img"></p><blockquote><p>如果不勾线创建 Readme 的话，在创建 Pages 之前必须提交写内容项目中</p></blockquote><p>完成后，点击 <code>Create repository</code> 创建项目</p><p>成功后，会打开创建项目的页面</p><h5 id="设置-pages"><a href="#设置-pages" class="headerlink" title="设置 pages"></a>设置 pages</h5><p>在项目页面选择 <code>Settings</code> 选项卡</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wNy5wbmc?x-oss-process=image/format,png" alt="img"></p><p>然后一直往下找到 GitHub Pages 节段，在 Souce 栏，点击 None 下拉菜单，选择第一项 <code>master branch</code>:</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wOC5wbmc?x-oss-process=image/format,png" alt="img"></p><p>页面会刷新，刷新后，就创建好了 Pages，并且显示出这个项目 Pages 的网址:</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wOS5wbmc?x-oss-process=image/format,png" alt="img"></p><p>其中 <code>Custom domain</code> 可以设置自己的域名</p><p>下面简单说下域名</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>域名是网络中的一个地址，比较方便记忆，另外有意义的域名对网站有一定的宣传作用，比如 mi.com</p><p>一个域名可以有无数个二级域名，比如 域名为 abc.com，二级域名可以是 erp.abc.com，blog.abc.com，docs.abc.com 等等，每个二级域名可以是不同的地址，或者说可以对应不同的网站</p><p>域名可以通过域名代理商购买，国内一般可以在 万网 上购买（目前万网并入阿里云），国外一般可以在 GoDaddy 上购买。域名是有有效期的，到期之前可以续费，以延长用于时间</p><p>有了域名后，可以在域名供应商提供的管理工具中设置域名对应的地址，叫做解析，可以将域名解析到自己的 GitHub Pages 上，例如我的：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8xMC5wbmc?x-oss-process=image/format,png" alt="img"></p><ul><li>记录类型有多种，CNAME 表示指向另一个网址</li><li>主记录可以设置二级域名</li><li>记录值，当记录类型为 CNAME 时，表示指向的一个网址，例如 自己的 GitHub Pages 地址</li></ul><p>这时就可以在 GitHub 的项目中 Settings 中的 GitHub Pages 节段中设置 <code>Custom domain</code> 了，填写自己的域名即可</p><p>设置完后，最多 24 小时后，访问自己的域名（主记录中的域名）就可以显示出自己的 GitHub Pages 了</p><h4 id="集成与部署"><a href="#集成与部署" class="headerlink" title="集成与部署"></a>集成与部署</h4><p>到此，所有的准备工作算是做完了，回顾一下，先搭建 Nodejs 环境，然后用 Npm 包管理工具安装 Hexo 应用，再由 Hexo 创建本地的博客系统，接下来注册 GitHub，并创建 Pages 项目，然后再设置域名，使通过域名可以访问到 Pages 项目</p><p>现在我们需要将本地的博客和 GitHub Pages 关联起来，以至于我们可以不用关注如何发布和运行博客系统，只需将精力集中在写作之上</p><p>首先将 Hexo 配置文件 _config.yml 中的 <code>url</code> 设置为自己的域名</p><p>然后，设置部署，在配置文件 _config.yml 中找到 <code>deploy</code>，配置为：</p><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/&lt;username&gt;/&lt;project&gt;</span>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><span class="hljs-number">1234</span></code></pre><ul><li>type 为部署类型，git 表示部署到 Git 远程仓库中</li><li>repo 为 GitHub 上项目的地址，注意这个地址不是 GitHub Pages 的网址，例如我的 项目地址为：<a href="https://github.com/alisx/alisx.github.io.git">https://github.com/alisx/alisx.github.io.git</a>, Pages 网址为：alisx.github.io</li><li>branch 为需要部署的项目分支，一般设置为主分支就可以</li></ul><p>最后，需要安装一个 Hexo 插件，用来与 GitHub 交互，在博客所在目录下，启动 Git Bash 命令行工具执行：</p><pre><code class="hljs cmd">npm install hexo-deployer-git --save</code></pre><p>现在就可以使用 <code>hexo deploy</code> 命令将本地博客部署到 GitHub Pages 上了</p><blockquote><p>部署时可能会提示输入 GitHub 的登录用户名及密码，按照提示输入即可</p></blockquote><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>现在一起就绪，如何来写作呢？</p><h5 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h5><p>在 Git 命令行中（只要是命令行都可以，不过 Git 命令行有高亮以及类 Linux 命令），进入博客根目录，输入 <code>hexo new draft my_first_article</code> 就可以在 <code>source</code> 文件夹下，创建一个名为 <code>my_first_article.md</code> 文件了，解释下这个命令</p><ul><li>new 表示创建一个文章</li><li>draft 意思为草稿，在这是其实是表示一个模板，即草稿模板，模板存放在 <code>scaffolds</code> 文件夹下，其中有个 <code>draft.md</code> 文件，另外还有 <code>post.md</code> 和 <code>page.md</code> 两个文件，在新建时使用模板，不仅会套用模板文件，还会将新建的文件放在 <code>source</code> 文件夹对应模板的文件夹中，例如上面的 <code>source\draft</code></li><li>最所以这么做，是因为处于 <code>draft</code> 状态的文章，不会被部署到博客上，只有在 <code>post</code> 和 <code>page</code> 状态的文章才会被部署</li></ul><h5 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h5><p>用 Markdown 编辑器，大概创建的草稿文件，例如 <code>my_first_article.md</code>，会发现文件中已经有了部分文字，这是来自于模板文件的，在最开头 <code>---</code> 之间的部分是文章的源信息，用来表示文章标题，作者，创建时间，分类，标签等信息，这些信息用于生成文章的 Html 页面</p><p>源信息之后，就是文章的正文部分，使用 Markdown 标记写作就可以了，如果不熟悉 Markdown 语法，请参考我之前写的 Markdown 教程: <a href="http://blog.lixiaofei.cn/2018-05-10-markdown/%EF%BC%8C%E8%AF%AD%E6%B3%95%E5%B9%B6%E4%B8%8D%E5%A4%8D%E6%9D%82%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E9%9C%80%E8%A6%81%E5%A4%9A%E5%8A%A0%E7%BB%83%E4%B9%A0%EF%BC%8C%E5%BD%A2%E6%88%90%E8%82%8C%E8%82%89%E8%AE%B0%E5%BF%86">http://blog.lixiaofei.cn/2018-05-10-markdown/，语法并不复杂，主要是需要多加练习，形成肌肉记忆</a></p><h5 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h5><p>预览是必要的环节，很多问题都是在这里发现的，虽然很多 Markdown 编辑器提供预览功能，但是能知道其在自己博客上的展示效果还是很有必要的</p><p>因为刚写的文章还在草稿状态，即在 <code>draft</code> 文件夹下，所以在预览时多加一个参数</p><pre><code class="hljs cmd">hexo server --draft</code></pre><p>这个命令和之前启动本地博客程序一样，不过多了个参数 <code>--draft</code>，其作用是可以将 draft 中的文章展示出来，从而达到预览的效果</p><h5 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h5><p>文章写完了，检查没有问题，就可以发布了</p><p>首先需要将文章从 <code>draft</code> 状态修改为 <code>post</code> 状态，使用命令 <code>hexo publish my_first_article</code>，执行完后，可以将 <code>draft</code> 文件夹中的名称为 <code>my_first_article.md</code> 的文章移动到 <code>post</code> 文件夹，来完成发布，此时执行 <code>hexo server</code> 不用加 <code>--draft</code> 参数就可以在浏览器中查看了</p><p>然后，需要将文章转换为 html 格式，因为 GitHub Pages 上只能展示静态的网页，使用的命令是 <code>hexo generate</code>，其会将 <code>post</code> 文件夹中的修改过的 Markdown 文件转换为 html 格式的文件。</p><blockquote><p>这里有两个问题，1 怎么知道哪些文件被修改过了；2 转换后的文件放哪里；<br>Hexo 会对文章建立索引，记录下来文章的指纹，如果文章被修改过，文章的指纹会改变，从而知道是否被修改，然后会将转换后的文件结合博客的其他结构放在 <code>public</code> 文件夹下，也就是整个博客的静态网页文件</p></blockquote><p>生成博客的静态网页文件之后，就可以部署到 GitHub Pages 上了，命令很简单 <code>hexo deploy</code>，执行完后，用自己的域名或者 GitHub Pages 提供的网址就可以访问了，如果没有变化，很可能是因为网站缓存，稍等下刷新就能看到了</p><p>博客上的文章发布完成了，怎么发布到其他平台呢？</p><p>这里介绍个 Markdown 美化工具 <a href="https://mdnice.com/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%B0%86">https://mdnice.com/，可以将</a> Markdown 文件转换为适合不同平台的 Html 格式</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8xMS5wbmc?x-oss-process=image/format,png" alt="img"></p><p>可以复制 Markdown 格式文件内容到左侧栏，或者通过 <code>文件</code> 菜单导入 Markdown 文件</p><p>可以通过 <code>主题</code> 菜单选择不同分格的主题</p><p>最后在最右侧，选择 公众号、知乎、掘金三个平台，会将转换后的复制到剪切板，然后粘贴到对应平台的文章编辑器中</p><p>这里有个问题，如果文章中有图片如何处理，因为在博客中，图片地址都是相对地址，直接复制上去是显示不出来的，所以复制之前，将图片相对地址替换为实际网址，例如本文中的图片相对地址为：<code>/images/2020/07/hexo-blog-guide/01.png</code>，替换为：<code>http://blog.lixiaofei.cn/images/2020/07/hexo-blog-guide/01.png</code>，如果图片较多的话，可以用编辑器的批量替换功能</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章比较长，感觉有些复杂，涉及的东西比较多比较杂，梳理一下就是 注册一个 GitHub，创建一个 Pages 项目，在本地安装一个 Hexo 博客系统，将本地博客发布到 Pages 上，虽然比较麻烦，但只做这么一次，搭建好了后，后面主要用来创作文章，会轻松很多。</p><p>事情总没有预想中梳理，如果过程中有问题，请给我留言，一起交流学习，总之，要相信没有解决不了的问题。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
