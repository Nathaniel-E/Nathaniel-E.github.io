<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Nginx笔记基于docker</title>
    <link href="/2020/08/30/Nginx%E7%AC%94%E8%AE%B0%E5%9F%BA%E4%BA%8Edocker/"/>
    <url>/2020/08/30/Nginx%E7%AC%94%E8%AE%B0%E5%9F%BA%E4%BA%8Edocker/</url>
    
    <content type="html"><![CDATA[<h3 id="Nginx介绍"><a href="#Nginx介绍" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h3><h4 id="1-1引言"><a href="#1-1引言" class="headerlink" title="1.1引言"></a>1.1引言</h4><pre><code class="hljs shell">为什么要学习Nginx问题1：客户端到底要将请求发送给哪台服务器问题2：如果所有客户端的请求都发送给了服务器问题3：客户端发送的请求可能是申请动态资源的，也有申请静态资源的</code></pre><pre><code class="hljs shell">服务器搭建集群后</code></pre><p><img src="https://img-blog.csdnimg.cn/20200804144611463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="Image text"></p><pre><code class="hljs shell">在搭建集群后，使用Nginx做反向代理</code></pre><p><img src="https://img-blog.csdnimg.cn/20200804144623426.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="{}}"></p><h4 id="1-2Nginx介绍"><a href="#1-2Nginx介绍" class="headerlink" title="1.2Nginx介绍"></a>1.2Nginx介绍</h4><p>Nginx是由俄罗斯人研发的，应对Rambler的网站并发，并且2004年发布的第一个版本。</p><pre><code class="hljs shell">Nginx的特点1.稳定性极强，7*24小时不间断运行(就是一直运行)2.Nginx提供了非常丰富的配置实例3.占用内存小，并发能力强(随便配置一下就是5w+,而tomcat的默认线程池是150)</code></pre><h3 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h3><h4 id="2-1安装Nginx"><a href="#2-1安装Nginx" class="headerlink" title="2.1安装Nginx"></a>2.1安装Nginx</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">在/opt目录下创建docker_nginx目录</span>cd /optmkdir docker_nginx<span class="hljs-meta">#</span><span class="bash">创建docker-compose.yml文件并编写下面的内容,保存退出</span>vim docker-compose.yml</code></pre><pre><code class="hljs json">version: &#x27;3.1&#x27;services:   nginx:    restart: always    image: daocloud.io/library/nginx:latest    container_name: nginx    ports:       - 80:80</code></pre><pre><code class="hljs shell">执行docker-compose up -d</code></pre><p>访问80端口，看到下图说明安装成功（ncthz.top是我阿里云服务器的域名，大家输入自己服务器的Ip就可以访问80端口了）</p><p><img src="https://img-blog.csdnimg.cn/20200804144702568.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="Image text"></p><h4 id="2-2Nginx的配置文件"><a href="#2-2Nginx的配置文件" class="headerlink" title="2.2Nginx的配置文件"></a>2.2Nginx的配置文件</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看当前nginx的配置需要进入docker容器中</span>docker exec -it 容器id bash<span class="hljs-meta">#</span><span class="bash">进入容器后</span>cd /etc/nginx/cat nginx.conf</code></pre><p>nginx.conf文件内容如下</p><pre><code class="hljs json">user  nginx;worker_processes  1;error_log  /var/log/nginx/error.log warn;pid        /var/run/nginx.pid;# 以上同城为全局块# worker_processes的数值越大，Nginx的并发能力就越强# error_log代表Nginx错误日志存放的位置# pid是Nginx运行的一个标识events &#123;    worker_connections  1024;&#125;# events块# worker_connections的数值越大，Nginx的并发能力就越强http &#123;    include       /etc/nginx/mime.types;    default_type  application/octet-stream;    log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;                      &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;                      &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;    access_log  /var/log/nginx/access.log  main;    sendfile        on;    #tcp_nopush     on;    keepalive_timeout  65;    #gzip  on;    include /etc/nginx/conf.d/*.conf;&#125;# http块# include代表引入一个外部文件# include       /etc/nginx/mime.types;mime.types中存放着大量媒体类型#include /etc/nginx/conf.d/*.conf;引入了conf.d下以.conf为结尾的配置文件</code></pre><p>conf.d目录下只有一个default.conf文件，内容如下</p><pre><code class="hljs json">server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;    #charset koi8-r;    #access_log  /var/log/nginx/host.access.log  main;    location / &#123;        root   /usr/share/nginx/html;        index  index.html index.htm;    &#125;# location块# root:将接受到的请求根据/usr/share/nginx/html去查找静态资源# index:默认去上述的路径中找到index.html或index.htm    #error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #    error_page   500 502 503 504  /50x.html;    location = /50x.html &#123;        root   /usr/share/nginx/html;    &#125;    # proxy the PHP scripts to Apache listening on 127.0.0.1:80    #    #location ~ \.php$ &#123;    #    proxy_pass   http://127.0.0.1;    #&#125;    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000    #    #location ~ \.php$ &#123;    #    root           html;    #    fastcgi_pass   127.0.0.1:9000;    #    fastcgi_index  index.php;    #    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;    #    include        fastcgi_params;    #&#125;    # deny access to .htaccess files, if Apache&#x27;s document root    # concurs with nginx&#x27;s one    #    #location ~ /\.ht &#123;    #    deny  all;    #&#125;&#125;# server块# listen代表Nginx监听的端口号# server_name代表Nginx接受请求的IP</code></pre><h4 id="2-3修改docker-compose文件"><a href="#2-3修改docker-compose文件" class="headerlink" title="2.3修改docker-compose文件"></a>2.3修改docker-compose文件</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">退出容器</span>exit<span class="hljs-meta">#</span><span class="bash">关闭容器</span>docker-compose down<span class="hljs-meta">#</span><span class="bash">修改docker-compose.yml文件如下</span></code></pre><pre><code class="hljs json">version: &#x27;3.1&#x27;services:   nginx:    restart: always    image: daocloud.io/library/nginx:latest    container_name: nginx    ports:       - 80:80    volumes:      - /opt/docker_nginx/conf.d/:/etc/nginx/conf.d</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">重新构建容器</span>docker-compose bulid<span class="hljs-meta">#</span><span class="bash">重新启动容器</span>docker-compose up -d</code></pre><p>这时我们再次访问80端口是访问不到的，因为我们映射了数据卷之后还没有编写server块中的内容</p><p>我们在/opt/docker_nginx/conf.d下新建default.conf，并插入如下内容</p><pre><code class="hljs json">server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;    location / &#123;        root   /usr/share/nginx/html;        index  index.html index.htm;    &#125;&#125;</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">重启nginx</span>docker-compose restart</code></pre><p>这时我们再访问80端口，可以看到是访问成功的</p><h3 id="Nginx的反向代理"><a href="#Nginx的反向代理" class="headerlink" title="Nginx的反向代理"></a>Nginx的反向代理</h3><h4 id="3-1正向代理和反向代理介绍"><a href="#3-1正向代理和反向代理介绍" class="headerlink" title="3.1正向代理和反向代理介绍"></a>3.1正向代理和反向代理介绍</h4><pre><code class="hljs shell">正向代理：1.正向代理服务是由客户端设立的2.客户端了解代理服务器和目标服务器都是谁3.帮助咱们实现突破访问权限，提高访问的速度，对目标服务器隐藏客户端的ip地址</code></pre><p><img src="https://img-blog.csdnimg.cn/20200804144856773.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="Image text"></p><pre><code class="hljs shell">反向代理：1.反向代理服务器是配置在服务端的2.客户端不知道访问的到底是哪一台服务器3.达到负载均衡，并且可以隐藏服务器真正的ip地址</code></pre><p><img src="https://img-blog.csdnimg.cn/20200804144918883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="Image text"></p><h4 id="3-2基于Nginx实现反向代理"><a href="#3-2基于Nginx实现反向代理" class="headerlink" title="3.2基于Nginx实现反向代理"></a>3.2基于Nginx实现反向代理</h4><pre><code class="hljs shell">准备一个目标服务器启动tomcat服务器编写nginx的配置文件(/opt/docker_nginx/conf.d/default.conf)，通过Nginx访问到tomcat服务器</code></pre><p>准备tomcat服务器</p><pre><code class="hljs shell">docker run -d -p 8080:8080 --name tomcat  daocloud.io/library/tomcat:8.5.15-jre8<span class="hljs-meta">#</span><span class="bash">或者已经下载了tomcat镜像</span>docker run -d -p 8080:8080 --name tomcat 镜像的标识<span class="hljs-meta">#</span><span class="bash">添加数据卷</span>docker run -it -v /宿主机绝对目录:/容器内目录 镜像名</code></pre><p>default.conf文件内容如下</p><pre><code class="hljs json">server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;    location / &#123;        proxy_pass http://ncthz.top:8080/;    &#125;&#125;</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">重启nginx</span>docker-compose restart</code></pre><p>这时我们访问80端口可以看到8080端口tomcat的默认首页</p><h4 id="3-3关于Nginx的location路径映射"><a href="#3-3关于Nginx的location路径映射" class="headerlink" title="3.3关于Nginx的location路径映射"></a>3.3关于Nginx的location路径映射</h4><pre><code class="hljs shell">优先级关系：(location = ) &gt; (location /xxx/yyy/zzz) &gt; (location ^~) &gt; (location ~,~*) &gt; (location /起始路径) &gt; (location /)</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1. = 匹配</span>location / &#123;<span class="hljs-meta">#</span><span class="bash">精准匹配，主机名后面不能带能和字符串</span><span class="hljs-meta">#</span><span class="bash">例如www.baidu.com不能是www.baidu.com/id=xxx</span>&#125;</code></pre><hr><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">2. 通用匹配</span>location /xxx &#123;<span class="hljs-meta">#</span><span class="bash">匹配所有以/xxx开头的路径</span><span class="hljs-meta">#</span><span class="bash">例如127.0.0.1:8080/xxxxxx可以为空，为空则和=匹配一样</span>&#125;</code></pre><hr><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">3. 正则匹配</span>location ~ /xxx &#123;<span class="hljs-meta">#</span><span class="bash">匹配所有以/xxx开头的路径</span>&#125;</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">4. 匹配开头路径</span>location ^~ /xxx/xx &#123;<span class="hljs-meta">#</span><span class="bash">匹配所有以/xxx/xx开头的路径</span>&#125;</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">5. 匹配结尾路径</span>location ~* \.(gif/jpg/png)$ &#123;<span class="hljs-meta">#</span><span class="bash">匹配以.gif、.jpg或者.png结尾的路径</span>&#125;</code></pre><p>修改/opt/docker_nginx/conf.d/default.conf如下</p><pre><code class="hljs json">server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;location /index &#123;        proxy_pass http://ncthz.top:8081/;#tomcat首页    &#125;location ^~ /CR/ &#123;        proxy_pass http://ncthz.top:8080/CR/;#毕设前台首页    &#125;    location / &#123;        proxy_pass http://ncthz.top:8080/CRAdmin/;#毕设后台首页    &#125;&#125;</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">重启nginx</span>docker-compose restart<span class="hljs-meta">#</span><span class="bash">访问ncthz.top/index可以进入tomcat首页</span><span class="hljs-meta">#</span><span class="bash">访问ncthz.top/CR/XXX可以进入毕设前台首页</span><span class="hljs-meta">#</span><span class="bash">访问ncthz.top或者ncthz.top:80可以进入毕设后台首页</span></code></pre><h3 id="Nginx负载均衡"><a href="#Nginx负载均衡" class="headerlink" title="Nginx负载均衡"></a>Nginx负载均衡</h3><pre><code class="hljs shell">Nginx为我们默认提供了三种负载均衡的策略：1.轮询：  将客户端发起的请求，平均分配给每一台服务器2.权重：  会将客户端的请求，根据服务器的权重值不同，分配不同的数量3.ip_hash:  基于发起请求的客户端的ip地址不同，他始终会将请求发送到指定的服务器上  就是说如果这个客户端的请求的ip地址不变，那么处理请求的服务器将一直是同一个</code></pre><h4 id="4-1轮询"><a href="#4-1轮询" class="headerlink" title="4.1轮询"></a>4.1轮询</h4><pre><code class="hljs shell">想实现Nginx轮询负载均衡机制只需要修改配置文件如下</code></pre><pre><code class="hljs json">upstream my_server&#123;    server ncthz.top:8080;    server ncthz.top:8081;&#125;server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;location / &#123;        proxy_pass http://my_server/;#tomcat首页    &#125;&#125;</code></pre><pre><code class="hljs json">upstream 名字&#123;    server ip:端口;    server 域名:端口;&#125;server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;location / &#123;        proxy_pass http://upstream的名字/;    &#125;&#125;</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">重启nginx</span>docker-compose restart</code></pre><p>多次刷新ncthz.top页面，根据版本号我们可以发现我们进入的是不同的tomcat</p><p><img src="https://img-blog.csdnimg.cn/20200804145017833.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="Image text"></p><p><img src="https://img-blog.csdnimg.cn/2020080414503175.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="Image text"></p><h4 id="4-2权重"><a href="#4-2权重" class="headerlink" title="4.2权重"></a>4.2权重</h4><pre><code class="hljs shell">实现权重的方式：在配置文件中upstream块中加上weight</code></pre><pre><code class="hljs json">upstream my_server&#123;    server ncthz.top:8080 weight=10;    server ncthz.top:8081 weight=2;&#125;server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;location / &#123;        proxy_pass http://my_server/;#tomcat首页    &#125;&#125;</code></pre><h4 id="4-3ip-hash"><a href="#4-3ip-hash" class="headerlink" title="4.3ip_hash"></a>4.3ip_hash</h4><pre><code class="hljs shell">实现ip_hash方式：在配置文件upstream块中加上ip_hash;</code></pre><pre><code class="hljs json">upstream my_server&#123;ip_hash;    server ncthz.top:8080 weight=10;    server ncthz.top:8081 weight=2;&#125;server &#123;    listen       80;    listen  [::]:80;    server_name  localhost;location / &#123;        proxy_pass http://my_server/;#tomcat首页    &#125;&#125;</code></pre><h3 id="Nginx动静分离"><a href="#Nginx动静分离" class="headerlink" title="Nginx动静分离"></a>Nginx动静分离</h3><pre><code class="hljs shell">Nginx的并发能力公式：  worker_processes * worker_connections / 4|2 = Nginx最终的并发能力动态资源需要/4，静态资源需要/2Nginx通过动静分离来提升Nginx的并发能力，更快的给用户响应</code></pre><h4 id="5-1动态资源代理"><a href="#5-1动态资源代理" class="headerlink" title="5.1动态资源代理"></a>5.1动态资源代理</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">配置如下</span>location / &#123;  proxy_pass 路径;&#125;</code></pre><h4 id="5-2静态资源代理"><a href="#5-2静态资源代理" class="headerlink" title="5.2静态资源代理"></a>5.2静态资源代理</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">停掉nginx</span>docker-compose down修改docker-compose.yml添加静态资源数据卷不同版本的静态资源位置可能不同，可以在2.2中查看默认的位置（location块中root后的路径）<span class="hljs-meta">#</span><span class="bash">启动nginx</span>docker-compose up -d</code></pre><pre><code class="hljs json">version: &#x27;3.1&#x27;services:   nginx:    restart: always    image: daocloud.io/library/nginx:latest    container_name: nginx    ports:       - 80:80    volumes:      - /opt/docker_nginx/conf.d/:/etc/nginx/conf.d      - /opt/docker_nginx/html/:/usr/share/nginx/html</code></pre><pre><code class="hljs json">在/opt/docker_nginx/html下新建一个index.html在index.html里面随便写点东西展示修改nginx的配置文件location / &#123;    root /usr/share/nginx/html;    index index.html;&#125;</code></pre><pre><code class="hljs json">#配置如下location / &#123;    root 静态资源路径;    index 默认访问路径下的什么资源;    autoindex on;#代表展示静态资源的全部内容，以列表的形式展开&#125;</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">重启nginx</span>docker-compose restart<span class="hljs-meta">#</span><span class="bash">访问ncthz.top如下</span></code></pre><p><img src="https://img-blog.csdnimg.cn/20200804145109582.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="Image text"></p><h3 id="Nginx集群"><a href="#Nginx集群" class="headerlink" title="Nginx集群"></a>Nginx集群</h3><h4 id="6-1引言"><a href="#6-1引言" class="headerlink" title="6.1引言"></a>6.1引言</h4><pre><code class="hljs shell">单点故障，避免nginx的宕机，导致整个程序的崩溃准备多台Nginx准备keepalived，监听nginx的健康情况准备haproxy，提供一个虚拟的路径，统一的去接收用户的请求</code></pre><p><img src="https://img-blog.csdnimg.cn/20200804145126982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ5NTU4ODUx,size_16,color_FFFFFF,t_70" alt="Image text"></p><h4 id="6-2搭建"><a href="#6-2搭建" class="headerlink" title="6.2搭建"></a>6.2搭建</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">先准备好以下文件放入/opt/docker_nginx_cluster目录中</span><span class="hljs-meta">#</span><span class="bash">然后启动容器注意确保80、8081和8082端口未被占用(或者修改docker-compose.yml中的端口)</span>docker-compose up -d然后我们访问8081端口可以看到master，访问8082端口可以看到slave因为我们设置了81端口的master优先级未200比82端口的slave优先级100高，所以我们访问80端口看到的是master现在我们模仿8081端口的nginx宕机了docker stop 8081端口nginx容器的ID这时我们再去访问80端口看到的就是slave了</code></pre><p>Dockerfile</p><pre><code class="hljs json">FROM nginx:1.13.5-alpineRUN apk update &amp;&amp; apk upgradeRUN apk add --no-cache bash curl ipvsadm iproute2 openrc keepalivedCOPY entrypoint.sh /entrypoint.shRUN chmod +x /entrypoint.shCMD [&quot;/entrypoint.sh&quot;]</code></pre><p>entrypoint.sh</p><pre><code class="hljs json">#!/bin/sh#/usr/sbin/keepalvined -n -l -D -f /etc/keepalived/keepalived.conf --dont-fork --log-console &amp;/usr/sbin/keepalvined -D -f /etc/keepalived/keepalived.confnginx -g &quot;daemon off;&quot;</code></pre><p>docker-compose.yml</p><pre><code class="hljs json">version: &quot;3.1&quot;services:  nginx_master:    build:      context: ./      dockerfile: ./Dockerfile    ports:      -8081:80    volumes:      - ./index-master.html:/usr/share/nnginx/html/index.html      - ./favicon.ico:/usr/share/nnginx/html/favicon.ico      - ./keepalived-master.conf:/etv/keepalived/keepalived.conf    networks:      static-network:        ipv4_address:172.20.128.2    cap_add:      - NET_ADMIN  nginx_slave:    build:      context: ./      dockerfile: ./Dockerfile    ports:      -8082:80    volumes:      - ./index-slave.html:/usr/share/nnginx/html/index.html      - ./favicon.ico:/usr/share/nnginx/html/favicon.ico      - ./keepalived-slave.conf:/etv/keepalived/keepalived.conf    networks:      static-network:        ipv4_address:172.20.128.3    cap_add:      - NET_ADMIN  proxy:    image:  haproxy:1.7-apline    ports:      - 80:6301    volumes:      - ./happroxy.cfg:/usr/local/etc/haproxy/haproxy.cfg    networks:      - static-networknetworks:  static-network:    ipam:      congig:        - subnet: 172.20.0.0/16</code></pre><p>keepalived-master.conf</p><pre><code class="hljs json">vrrp_script chk_nginx &#123;    script &quot;pidof nginx&quot;    interval 2&#125;vrrp_instance VI_1 &#123;    state MASTER    interface etch0#容器内部的网卡名称    virtual_router_id 33    priority 200#优先级    advert_int 1        autheentication &#123;    auth_type PASS    auth_pass letmein&#125;virtual_ipaddress &#123;        172.20.128.50#虚拟路径    &#125;track_script &#123;        chk_nginx    &#125;&#125;</code></pre><p>keepalived-slave.conf</p><pre><code class="hljs json">vrrp_script chk_nginx &#123;    script &quot;pidof nginx&quot;    interval 2&#125;vrrp_instance VI_1 &#123;    state BACKUP    interface etch0#容器内部的网卡名称    virtual_router_id 33    priority 100#优先级    advert_int 1        autheentication &#123;    auth_type PASS    auth_pass letmein&#125;virtual_ipaddress &#123;        172.20.128.50#虚拟路径    &#125;track_script &#123;        chk_nginx    &#125;&#125;</code></pre><p>haproxy.cfg</p><pre><code class="hljs json">globallog 127.0.0.1 local0maxconn 4096daemonnbproc 4defaultslog 127.0.0.1 local3mode httpoption dontlognulloption redispatchretries 2maxconn 2000balance roundrobintimeout connect 5000mstimeout client 5000mstimeout server 5000msfrontend mainbind *:6301default_backend webserverbackend webserveerserver nginx_master 127.20.127.50:80 check inter 2000 rise 2 fall 5</code></pre><p>index-master.html</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>master！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre><p>index-slave.html</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>slave！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Git+hexo搭建个人博客</title>
    <link href="/2020/08/30/%E4%BD%BF%E7%94%A8Git-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/08/30/%E4%BD%BF%E7%94%A8Git-hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>用流行的 Hexo 博客系统，利用 Github Pages，搭建个人博客，使用 Markdown 语法进行写作，发布博客后，借用 Markdown 美化工具，生成公众号、知乎、头条等平台的文章格式，发布到相应平台。</p><h3 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h3><ul><li><p><strong>Hexo</strong><br>Hexo 是流行的博客框架，能集成多种插件和主题，可以生成各种类型的博客，具有很好的生态圈，并且在不断升级优化中，不用担心年久失修。</p></li><li><p><strong>Github pages</strong><br>Github 是一个基于 Git 版本管理工具的代码托管平台，是全球最大的开源代码平台，pages 是 Github 给用户提供的一种建立静态网页的服务，创建好之后，只要将做好的静态页面上传到 Github 上，就能被全球的能联网的人访问了。</p></li><li><p><strong>Markdown</strong><br>Markdown 是一种简单标记方法，使用简单规则，就可以做出美观的页面，比使用 Html 标记等语言制作页面方便的多，熟悉了标记规则之后，创作过程可以完全忘记标记的存在，并且大多数编辑器，包括在线编辑器都支持 。Markdown 语法，使用 Markdown 语法写的文章，可以很方便的在不同平台上共享，而不用担心文章格式受到改变。</p></li><li><p><strong>Markdown 美化工具</strong><br>Markdown 之所以简单，是因为它只提炼了文章格式相关的标记，比如标题，列表，加粗，斜体，代码块等，而将样式部分完全交给了解释程序，也就是说相同的格式可以被美化为不同风格的文章样式，所以就有了 Markdown 美化工具，只要将 markdown 文本粘贴到编辑器，就能查看美化后的效果，并且还可以切换不同风格，直到自己满意。<br>简单说 Markdown 美化工具就是将 markdown 文本转换为 Html 文本。</p></li><li><p><strong>操作系统</strong><br>Hexo 是基于 Nodejs 的，所以支持 Windows、Linux 和 MacOS，这里只以 Windows 为例讲解。</p><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>Hexo 是基于 Nodejs 的，也就是用 Nodejs 写的一个应用，另外 Hexo 相关组件和包都是放在 Github 上的，所以还需要一个 git 工具，以便和 Github 交互</p><h3 id="安装-nvm"><a href="#安装-nvm" class="headerlink" title="安装 nvm"></a>安装 nvm</h3><p>Nodejs 版本很多，软件包也很多，常常令初学者头疼，现在有了专门管理 Nodejs 环境的工具 nvm，通过 nvm 可以简单的安装不同版本的 Nodejs，并且可以在不同版本之间切换，从而解决 Nodejs 的版本混乱问题</p><ol><li>下载安装包<br>这里这里 <a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a> 选择最新版本的安装包，下载 zip 文件，例如目前最新版是 1.1.7，下载地址是<br><a href="https://github.com/coreybutler/nvm-windows/releases/download/1.1.7/nvm-noinstall.zip">https://github.com/coreybutler/nvm-windows/releases/download/1.1.7/nvm-noinstall.zip</a></li><li>将下载的 zip 包解压到你的程序安装目录，例如 D:\Software\nvm</li><li>在刚才解压的文件夹，双击运行 install.cmd 文件，中间可能会提示需要使用管理员权限，选择是即可</li><li>由于 nodejs 软件目录国内访问较慢，有必要设置下软件源，即让 nvm 从指定的地方下载 nodejs，方法是在环境变量中加一个 <code>NVM_NODEJS_ORG_MIRROR=https://npm.taobao.org/mirrors/node</code><br>如果不清楚如何设置，可以参考这里<a href="https://jingyan.baidu.com/article/8ebacdf02d3c2949f65cd5d0.html">https://jingyan.baidu.com/article/8ebacdf02d3c2949f65cd5d0.html</a></li></ol><h3 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h3><p>有了 nvm 就能轻松地安装 nodejs 了</p><p>打开一个命令行窗口，输入 <code>nvm install 12.18.2</code></p><p><code>12.18.2</code> 为 nodejs 目前最新的稳定版本号，可以在这里参看最新的版本号 <a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p><p>成功安装后，在命令行中输入 node –version 就可以看到版本号信息，如 v12.18.2，安装 nodejs 的同时，会安装好 npm，即 nodejs 的软件包管理器，用来管理 nodejs 的各种扩展软件包，如果了解 python 的话，和 pip 很相似</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>Hexo 实际上是一个 nodejs 的软件包，可以通过 npm 来安装，在安装之前，最好换以下 npm 的软件源，以便国内访问更快些，在命令行中输入命令：</p><pre><code class="hljs shell">nvm node_mirror https://npm.taobao.org/mirrors/node/nvm npm_mirror https://npm.taobao.org/mirrors/npm/</code></pre><p>注意用的是 nvm 而不是 npm，这两个命令，会在 nvm 安装文件夹下创建一个 settings.txt 文件，写入镜像网址，当然不用上述命令，自己创建 settings.txt,输入镜像网址也是一样的，settings.txt 内容为：</p><pre><code class="hljs shell">node_mirror: https://npm.taobao.org/mirrors/node/npm_mirror: https://npm.taobao.org/mirrors/npm/</code></pre><ul><li>注意这里用的是 <strong>npm</strong> 而不是 nvm</li><li>参数 g 表示全局安装，即在任何目录下都可以使用</li></ul><p>安装完成后，输入 <code>hexo --version</code> 可以看到包括 hexo 版本在内一些环境信息</p><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p>Git 可以管理本地的软件版本，也能和 Github 打交道，而且 GIT 工具集成了 Linux 的命令环境，可以在 Git 命令行下使用 Linux 命令，而且语法高亮，比较方便</p><p>下载 Git windows 安装程序 <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p><p>完成后，双击运行安装程序</p><p>一路选择默认设计就行，因为配置项很多，如果不想一步步选，可以勾选安装窗口的 <code>only show new options</code> 勾选框</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wMS5wbmc?x-oss-process=image/format,png" alt="git 安装选项"></p><p>安装完成后，如果不使用 git 来管理代码（对于写作来说就是文章），可以不用关注 git 的相关用法，只要知道可以通过鼠标右键菜单，启动一个 git 命令窗口就行了</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wMi5wbmc?x-oss-process=image/format,png" alt="Git Bash Here "></p><blockquote><p>安装时不同的选择导致的快捷菜单可能不同</p></blockquote><h3 id="创建博客"><a href="#创建博客" class="headerlink" title="创建博客"></a>创建博客</h3><p>环境准备好后，就可以构建博客系统了.</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>创建一个博客目录，例如：<code>D:\myblog</code>，到改目录下，鼠标右键，选择 <code>Git Bash Here</code> 菜单，会进入一个命令行窗口，和 Windows 的命令行窗口类似</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wMy5wbmc?x-oss-process=image/format,png" alt="git 命令窗口"></p><p>在这里输入命令 <code>hexo init</code>，回车，会下载博客程序，当提示 <code>INFO Start blogging with Hexo!</code> 时候，说明创建完成</p><p>接着输入 <code>hexo server</code> 或者 <code>hexo s</code> 启动 Hexo 博客程序了</p><p>在浏览器中输入 localhost:4000，就可以查看博客了</p><blockquote><p>有时候 localhost:4000 没有很长时间没有反应，可能是 4000 端口被其他程序占用了，这时输入 Ctrl + C 结束 Hexo 程序，换个端口启动就好了，例如 <code>hexo s -p 5000</code> , 参数 <code>-p</code> 表示指定端口，5000 为指定的端口</p></blockquote><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>默认启动的博客是英文版的，另外默认的主题是 landscape，如果不喜欢可以更好</p><p>在博客根目录下，<code>_config.yml</code> 为配置文件，配置项很多，只需要设置很少部分就可以</p><p>站点设置 site，设置博客站点的基本信息</p><ul><li>title 站点名称</li><li>subtitle 副标题</li><li>description 站点描述</li><li>keywords 站点关键字，方便搜索引擎归类</li><li>author 作者名称</li><li>language 语言，简体中文为 <code>zh-CN</code></li><li>timezone 时区</li></ul><p>域名设置 URL，即为博客设置个网址</p><ul><li>url 网址，例如 <a href="http://blog.lixiaofei.cn/">http://blog.lixiaofei.cn</a></li><li>root 表示博客的根目录，如果设置为 /blog 那么网址会是 url 加上这个根路径</li><li>permalink 为固定网址，表示每篇文章的网址组成部分</li></ul><blockquote><p>如果自己的域名，需要购买，例如在万网上购买，之后需要实名认证，然后将域名解析到博客服务器地址上，服务器地址将在 Github pages 部分详细说明</p></blockquote><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>Hexo 自带了 landscape 主题，可以跟换其他的</p><p>在 <a href="https://hexo.io/themes/index.html">https://hexo.io/themes/index.html</a> 这里预览可用主题</p><p>选择喜欢的主题，找到 github 地址，一般都在预览页中有提供，复制主题项目的 github 地址：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wNC5wbmc?x-oss-process=image/format,png" alt="img"></p><p>进入博客根目录，右键选择 <code>Git Bash Here</code>，打开 git 命令行，输入 <code>git clone [主题github 项目地址地址] theme/[主题英文名称]</code> 回车执行</p><p>执行完成后，博客目录下 theme 里 会多一个 主题英文名称的文件夹，这就是刚才下载的主题</p><p>打开 Hexo 配置文件 <code>_config.yml</code> 找到 <code>theme</code> 配置项，修改为 <code>主题英文名称</code></p><p>正常情况下刷浏览器的页面就可以看到新主题效果了，如果不行，执行下 <code>hexo server</code> 就可以了</p><p>每个主题有自己不同的配置项，配置文件是对应主题文件夹中的 <code>_config.yml</code>，相关配置可以参考该主题的帮助文档</p><p>这里建议选择使用者多，支持丰富的主题，相对而言文档全，bug 少</p><h4 id="Github"><a href="#Github" class="headerlink" title="Github"></a>Github</h4><p>Github 不仅是很多开源软件的仓库，还可以成为我们博客的服务器，最重要的是免费，国内有类似的产品 Gitee（码云）提供类似功能</p><h5 id="注册和创建项目"><a href="#注册和创建项目" class="headerlink" title="注册和创建项目"></a>注册和创建项目</h5><p>访问 <a href="https://github.com/">https://github.com</a>，选择 sign up 填写必要信息完成注册，注册完成后，点击 sign in 登录</p><p>登录后，点击页面右上角附近的 <code>加号</code>，在弹出菜单中选择 <code>New repository</code></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wNS5wbmc?x-oss-process=image/format,png" alt="img"></p><p>在打开的页面中，填写项目名称，可以随要填写，因为作为博客使用，选择公开仓库，并且勾选为项目创建 <code>Readme</code></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wNi5wbmc?x-oss-process=image/format,png" alt="img"></p><blockquote><p>如果不勾线创建 Readme 的话，在创建 Pages 之前必须提交写内容项目中</p></blockquote><p>完成后，点击 <code>Create repository</code> 创建项目</p><p>成功后，会打开创建项目的页面</p><h5 id="设置-pages"><a href="#设置-pages" class="headerlink" title="设置 pages"></a>设置 pages</h5><p>在项目页面选择 <code>Settings</code> 选项卡</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wNy5wbmc?x-oss-process=image/format,png" alt="img"></p><p>然后一直往下找到 GitHub Pages 节段，在 Souce 栏，点击 None 下拉菜单，选择第一项 <code>master branch</code>:</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wOC5wbmc?x-oss-process=image/format,png" alt="img"></p><p>页面会刷新，刷新后，就创建好了 Pages，并且显示出这个项目 Pages 的网址:</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8wOS5wbmc?x-oss-process=image/format,png" alt="img"></p><p>其中 <code>Custom domain</code> 可以设置自己的域名</p><p>下面简单说下域名</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>域名是网络中的一个地址，比较方便记忆，另外有意义的域名对网站有一定的宣传作用，比如 mi.com</p><p>一个域名可以有无数个二级域名，比如 域名为 abc.com，二级域名可以是 erp.abc.com，blog.abc.com，docs.abc.com 等等，每个二级域名可以是不同的地址，或者说可以对应不同的网站</p><p>域名可以通过域名代理商购买，国内一般可以在 万网 上购买（目前万网并入阿里云），国外一般可以在 GoDaddy 上购买。域名是有有效期的，到期之前可以续费，以延长用于时间</p><p>有了域名后，可以在域名供应商提供的管理工具中设置域名对应的地址，叫做解析，可以将域名解析到自己的 GitHub Pages 上，例如我的：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8xMC5wbmc?x-oss-process=image/format,png" alt="img"></p><ul><li>记录类型有多种，CNAME 表示指向另一个网址</li><li>主记录可以设置二级域名</li><li>记录值，当记录类型为 CNAME 时，表示指向的一个网址，例如 自己的 GitHub Pages 地址</li></ul><p>这时就可以在 GitHub 的项目中 Settings 中的 GitHub Pages 节段中设置 <code>Custom domain</code> 了，填写自己的域名即可</p><p>设置完后，最多 24 小时后，访问自己的域名（主记录中的域名）就可以显示出自己的 GitHub Pages 了</p><h4 id="集成与部署"><a href="#集成与部署" class="headerlink" title="集成与部署"></a>集成与部署</h4><p>到此，所有的准备工作算是做完了，回顾一下，先搭建 Nodejs 环境，然后用 Npm 包管理工具安装 Hexo 应用，再由 Hexo 创建本地的博客系统，接下来注册 GitHub，并创建 Pages 项目，然后再设置域名，使通过域名可以访问到 Pages 项目</p><p>现在我们需要将本地的博客和 GitHub Pages 关联起来，以至于我们可以不用关注如何发布和运行博客系统，只需将精力集中在写作之上</p><p>首先将 Hexo 配置文件 _config.yml 中的 <code>url</code> 设置为自己的域名</p><p>然后，设置部署，在配置文件 _config.yml 中找到 <code>deploy</code>，配置为：</p><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/&lt;username&gt;/&lt;project&gt;</span>  <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><span class="hljs-number">1234</span></code></pre><ul><li>type 为部署类型，git 表示部署到 Git 远程仓库中</li><li>repo 为 GitHub 上项目的地址，注意这个地址不是 GitHub Pages 的网址，例如我的 项目地址为：<a href="https://github.com/alisx/alisx.github.io.git">https://github.com/alisx/alisx.github.io.git</a>, Pages 网址为：alisx.github.io</li><li>branch 为需要部署的项目分支，一般设置为主分支就可以</li></ul><p>最后，需要安装一个 Hexo 插件，用来与 GitHub 交互，在博客所在目录下，启动 Git Bash 命令行工具执行：</p><pre><code class="hljs cmd">npm install hexo-deployer-git --save</code></pre><p>现在就可以使用 <code>hexo deploy</code> 命令将本地博客部署到 GitHub Pages 上了</p><blockquote><p>部署时可能会提示输入 GitHub 的登录用户名及密码，按照提示输入即可</p></blockquote><h3 id="写作"><a href="#写作" class="headerlink" title="写作"></a>写作</h3><p>现在一起就绪，如何来写作呢？</p><h5 id="新建"><a href="#新建" class="headerlink" title="新建"></a>新建</h5><p>在 Git 命令行中（只要是命令行都可以，不过 Git 命令行有高亮以及类 Linux 命令），进入博客根目录，输入 <code>hexo new draft my_first_article</code> 就可以在 <code>source</code> 文件夹下，创建一个名为 <code>my_first_article.md</code> 文件了，解释下这个命令</p><ul><li>new 表示创建一个文章</li><li>draft 意思为草稿，在这是其实是表示一个模板，即草稿模板，模板存放在 <code>scaffolds</code> 文件夹下，其中有个 <code>draft.md</code> 文件，另外还有 <code>post.md</code> 和 <code>page.md</code> 两个文件，在新建时使用模板，不仅会套用模板文件，还会将新建的文件放在 <code>source</code> 文件夹对应模板的文件夹中，例如上面的 <code>source\draft</code></li><li>最所以这么做，是因为处于 <code>draft</code> 状态的文章，不会被部署到博客上，只有在 <code>post</code> 和 <code>page</code> 状态的文章才会被部署</li></ul><h5 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h5><p>用 Markdown 编辑器，大概创建的草稿文件，例如 <code>my_first_article.md</code>，会发现文件中已经有了部分文字，这是来自于模板文件的，在最开头 <code>---</code> 之间的部分是文章的源信息，用来表示文章标题，作者，创建时间，分类，标签等信息，这些信息用于生成文章的 Html 页面</p><p>源信息之后，就是文章的正文部分，使用 Markdown 标记写作就可以了，如果不熟悉 Markdown 语法，请参考我之前写的 Markdown 教程: <a href="http://blog.lixiaofei.cn/2018-05-10-markdown/%EF%BC%8C%E8%AF%AD%E6%B3%95%E5%B9%B6%E4%B8%8D%E5%A4%8D%E6%9D%82%EF%BC%8C%E4%B8%BB%E8%A6%81%E6%98%AF%E9%9C%80%E8%A6%81%E5%A4%9A%E5%8A%A0%E7%BB%83%E4%B9%A0%EF%BC%8C%E5%BD%A2%E6%88%90%E8%82%8C%E8%82%89%E8%AE%B0%E5%BF%86">http://blog.lixiaofei.cn/2018-05-10-markdown/，语法并不复杂，主要是需要多加练习，形成肌肉记忆</a></p><h5 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h5><p>预览是必要的环节，很多问题都是在这里发现的，虽然很多 Markdown 编辑器提供预览功能，但是能知道其在自己博客上的展示效果还是很有必要的</p><p>因为刚写的文章还在草稿状态，即在 <code>draft</code> 文件夹下，所以在预览时多加一个参数</p><pre><code class="hljs cmd">hexo server --draft</code></pre><p>这个命令和之前启动本地博客程序一样，不过多了个参数 <code>--draft</code>，其作用是可以将 draft 中的文章展示出来，从而达到预览的效果</p><h5 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h5><p>文章写完了，检查没有问题，就可以发布了</p><p>首先需要将文章从 <code>draft</code> 状态修改为 <code>post</code> 状态，使用命令 <code>hexo publish my_first_article</code>，执行完后，可以将 <code>draft</code> 文件夹中的名称为 <code>my_first_article.md</code> 的文章移动到 <code>post</code> 文件夹，来完成发布，此时执行 <code>hexo server</code> 不用加 <code>--draft</code> 参数就可以在浏览器中查看了</p><p>然后，需要将文章转换为 html 格式，因为 GitHub Pages 上只能展示静态的网页，使用的命令是 <code>hexo generate</code>，其会将 <code>post</code> 文件夹中的修改过的 Markdown 文件转换为 html 格式的文件。</p><blockquote><p>这里有两个问题，1 怎么知道哪些文件被修改过了；2 转换后的文件放哪里；<br>Hexo 会对文章建立索引，记录下来文章的指纹，如果文章被修改过，文章的指纹会改变，从而知道是否被修改，然后会将转换后的文件结合博客的其他结构放在 <code>public</code> 文件夹下，也就是整个博客的静态网页文件</p></blockquote><p>生成博客的静态网页文件之后，就可以部署到 GitHub Pages 上了，命令很简单 <code>hexo deploy</code>，执行完后，用自己的域名或者 GitHub Pages 提供的网址就可以访问了，如果没有变化，很可能是因为网站缓存，稍等下刷新就能看到了</p><p>博客上的文章发布完成了，怎么发布到其他平台呢？</p><p>这里介绍个 Markdown 美化工具 <a href="https://mdnice.com/%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%B0%86">https://mdnice.com/，可以将</a> Markdown 文件转换为适合不同平台的 Html 格式</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cDovL2Jsb2cubGl4aWFvZmVpLmNuL2ltYWdlcy8yMDIwLzA3L2hleG8tYmxvZy1ndWlkZS8xMS5wbmc?x-oss-process=image/format,png" alt="img"></p><p>可以复制 Markdown 格式文件内容到左侧栏，或者通过 <code>文件</code> 菜单导入 Markdown 文件</p><p>可以通过 <code>主题</code> 菜单选择不同分格的主题</p><p>最后在最右侧，选择 公众号、知乎、掘金三个平台，会将转换后的复制到剪切板，然后粘贴到对应平台的文章编辑器中</p><p>这里有个问题，如果文章中有图片如何处理，因为在博客中，图片地址都是相对地址，直接复制上去是显示不出来的，所以复制之前，将图片相对地址替换为实际网址，例如本文中的图片相对地址为：<code>/images/2020/07/hexo-blog-guide/01.png</code>，替换为：<code>http://blog.lixiaofei.cn/images/2020/07/hexo-blog-guide/01.png</code>，如果图片较多的话，可以用编辑器的批量替换功能</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>这篇文章比较长，感觉有些复杂，涉及的东西比较多比较杂，梳理一下就是 注册一个 GitHub，创建一个 Pages 项目，在本地安装一个 Hexo 博客系统，将本地博客发布到 Pages 上，虽然比较麻烦，但只做这么一次，搭建好了后，后面主要用来创作文章，会轻松很多。</p><p>事情总没有预想中梳理，如果过程中有问题，请给我留言，一起交流学习，总之，要相信没有解决不了的问题。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
